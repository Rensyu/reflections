lesson2ではrepositoryの新規作成とcommitの仕方を学ぶ。
また、Gitにおけるmergeやbranch、そしてこれらのツールを使用して自分のプロジェクトの
試験的変更を追跡する方法を学ぶ。

lesson3ではGitHubを使って複数のマシーンに渡って協力的にGitを使用する方法を学ぶ。

何がrepositoryをrepositoryたらしめるのか？
repositoryは、大部分はPCの普通のディレクトリと同じに見える。唯一の本当に異なる点は、git repositoryは
repositoryが作成されてからのrepositoryの履歴のメタデータの束を貯めている。
メタデータはmainディレクトリにあるが、不可視ディレクトリにしまい込まれている。
不可視ファイルや不可視ディレクトリはユーザーが直接やり取りする必要がない場合によく使用される。
不可視ディレクトリや不可視ファイルはピリオドから始まる名前がついている。

ls -aと-aオプションを付けると不可視ディレクトリや不可視ファイルが見られる。

前回、既存のrepositoryをクローンしたが、全てのメタデータを自分のローカルPCに持ってきたということだ。

もしrepositoryをスクラッチから作成したい場合は、gitに明確に新しいrepositoryを作りたいと言わなければならない。

repositoryの新規作成はオフラインで出来る。そのrepositoryにcommitを追加するのもオフラインで出来る。
空のディレクトリに後でファイルを作成することも、ファイルが既にあるディレクトリにrepositoryを作成することも
出来る。

git init
初期化、またはGit repositoryを新規作成する。不可視の.gitディレクトリが作成される。ls -aで確認出来る。
新規作成したrepositoryにはcommitは0個。commitは自分でする。
ディレクトリに全て揃っていれば、Gitは最初のcommitが出来るかもしれないが、いくつかの理由により、それは
出来ない。
第一に、あなたがディレクトリの全ファイルをcommitしたくないかもしれない。
第二に、もしGitがあなたの代わりにcommitしたら、あなたが自分でcommitメッセージを書けなくなる

repositoryにどんなcommitがあるのかgit logで見てみる。

エラー fatal:bad default version !HEAD!
Gitでは現在のcommitをHEADと呼ぶ。このエラーはrepositoryに何もcommitが無いのでコメント履歴を表示
出来ないと伝えてくれている。

git status
git statusは直近のcommitから、どのファイルが変更されたか表示してくれる。
commitが一個もない時は、Initial commitと表示される。
Untracked Filesと表示されたファイルは、まだtrackの履歴がない。

What happens when you initialize a repository? Why do you need to do it?
repositoryを初期化した時、なにが起きましたか？どうして初期化する必要がありますか？

git initを実行すると不可視フォルダ.gitがが作成されて、そこに履歴管理等のメタデータが準備される。
初期化しないと、単なる普通のディレクトリのまんまでバージョンコントロール出来ない。

repositoryに変更を追加するやり方
作業中のディレクトリに3つのファイルがある。一方には空の新規作成したrepositoryがある。
このrepositoryにcommitを追加したい。この自分のファイルの現在の状態スナップショットを
作成するにはgit commitを実行するだけで良いのでは？と思うかもしれないが、
gitはこれよりも少し操作を要求する。
一つの論理的変更(logical change)につき、一つのcommitで、出来るだけcommitは小さく保つの
が良い考えだということを思い出して。
どんな変更がcommitされるべきかを厳密に明記することを要求することによってGitはこれを容易にしている。
これを実現するために、gitにはStaging Areaと呼ばれる中間地帯、媒介地帯を利用する。
Staging Areaには一回に1つのファイルを追加出来る。一回に一個づつStaging Areaに追加した後に、
GitはStaging Areaの全内容(ファイル)を1つのcommitとしてまとめて、それをrepositoryに追加する。
これをコマンドラインで見てみよう。

今までrepositoryに何を追加したのか確認する場合にはgit statusを使う。
新規作成したrepositoryは1回もcommitされていないのでInitial commitとUntracked Filesが表示される。

Staging Areaにファイルを追加するにはgit addコマンドを使う。
git add ファイル名
一個ずつ実行してStaging Areaにファイルを登録していく。

Staging Areaに登録されたかどうかをgit statusで確認する。
Changes to be commited:以下にnew file:として登録されたファイルが表示される。

新規commitを作成する際には、これらのファイル(Staging Areaに登録されたファイル)が含まれる。

lesson1とlesson2は論理的に分離しているのでgit addしなかった。

concept map

initはrepositoryを新規作成する。initはrepository上で動作する。(operates-on)

staging area。commitを作る前に、ファイルをstaging areaに登録する。なので、staging areaは
commitに密接に関連している。

git addとgit statusは両方ともstaging areaでcommitを作るのを助ける。

git statusはworking directoryの内容も表示する。なのでgit statusはworking directoryと
staging area上で動作(operates-on)

git addはstaging area上で動作(operates-on)

How is the staging area different from the working directory and the repository?
What value do you think it offers?
staging areaはworking　directoryとrepositoryとどのように違うのか？
それはどんな価値を提供していると思いますか？

staging areaはrepositoryにcommitするための準備をする場所。
working areaのファイル群からrepositoryに置きたいファイルを自分で選んで1個づつ
staging areaに登録(git add)してから、まとめてrepositoryに置く。
working areaは単なるディレクトリ、repositoryはgit initで初期化され、メタデータがある場所、
staging areaはworking directoryとrepositoryを媒介するバーチャルな場所。

Lesson 1でworkplaceを正しく設定した場合、git commitを実行すると、すぐにcommit messageの
入力になる。

git commitの代わりにgit commit -m "Commit message"でcommit messageを指定することができる。

git messageのスタイルは人によって異なるが、http://udacity.github.io/git-styleguide/
を参考にすると良い。

staging areaにファイルを登録したので、今度はそれらの変更をcommitするやり方に進もう。

git commit
git commitを実行すると、Lesson 1で設定したおかげでEditorが開くのでcommit messageを入力する。

commit messageには過去形は使わない。命令形で書く。"変更した"ではなく"変更"で良い

commit messageの編集が終わったら、ファイルを保存してeditorを終了。

git commit出来たかgit logで確認する。

git statusを実行してみると、Initial commitの注意書きが消えているはず。
working areaにrepositoryに登録しなかったファイルが残っている場合には、
Untracked Files:が表示される。

working areaの変更を全てrepositoryに登録してcommitすると
git statusでnothing to commit, working directory cleanとなる。

ファイルの内容を変更して、一休みして戻ってくると、どんな変更をしたのか忘れていることがある。
そこで、git diffを使ってcommitしてから、自分がどんな変更をしたのか正確に見てみる。

working directory,staging area,repositoryが今どんな状態か見てみよう。

repositoryにはcommitがいくつか含まれている。そして、各commitはいくつかのファイルを含んでいる。
今は最新のcommitの中のgame.jsとindex.htmlに注目する。

staging areaは私が変更をaddするまでは、単に最新のcommitのコピーなのでrepositoryと同じファイルがある。

最期にworking directoryを見てみると、repository、staging areaと同じファイルを持っているが、
game.jsとindex.htmlを変更した。

git diffを使ってIDを入力して2つのcommitを比較することができるのは知っているが、
staging areaとworking directoryはcommitではないのでIDを持っていない。
しかしながら、Gitユーザーがworking directoryとstaging areaを比較したいのは当然なので、
git diffを引数無しで使うとそれが出来る。

引数無しのgit diffを使うと、working directoryで変更したけど、staging areaにはまだ登録していない
変更が表示される。

今度はrepositoryの最新のcommitとstaging areaのdifferenceを見たいと思うかもしれない。
私は、staging areaにaddしたファイルが本当にrepositoryの
commitに置きたいファイルなのかcommitの直前にダブルチェックとして
最新のcommitとstaging areaのdifferenceを見たい。

最新のcommitとstaging areaのdifferenceを見るときのコマンドは

git diff --staged

最期に、staging areaのファイルが、本当にcommitに追加したいファイルでは無かった場合、
そのファイルをstaging areaから取り除くには

git reset --hard

working directoryかstaging areaの変更を破棄する。

しかし、git reset --hardを使う時は注意してください。
gitの殆どのactionは、いつでも前のcommitに戻れるので可逆ですが、
working directoryとstaging areaはcommitではないので。
もしgit reset --hardを使ったら、それらの変更は元に戻せません。

git diffの各フォームはどんな2つのバージョンを比較しますか？

まとめ
引数無しgit diffはworking directoryとstaging areaを比較
git diff --stagedはstaging areaと最新のcommitを比較
git diff commitID1 commitID2はcommitID1とcommitID2を比較

'detatched HEAD'状態から抜けるには
Lesson1で古いcommitをcheckoutしてから'detatched'状態のままです。
これを直すには、git checkout masterを実行します。
(実行前は緑字で((25ede83...))と表示されていたが、実行後はPrevious HEAD position was 25ede83...
 a couple missing ends with the ipad version　Switched to branch 'master'(master)になった。)

 今までのLessonのcommit IDは動画と同じだったが、今回のcommit IDは動画と異なるはずだ。
 何故なら、commit IDは時間、作者、message等から生成されるから。
 commit ID生成の詳細は
 https://git-scm.com/book/en/v2/Git-Internals-Git-Objects

 How can you use the staging area to make sure you have one commit per logical change?

 あなたが論理的変更につき1個のcommitをしたと確認するのに、どのようにstaging areaを使うことができますか？

 まずworking directoryで変更した内容がstaging areaに登録されているか確認する。
 git diff　引数無しでworking directoryとstaging areaを比較。登録されていなければdiffの
 内容が表示される。git addでstaging areaに登録。

 次にrepositoryの最新のcommitとstaging areaの内容を比較
 git diff --staged
 これで最新のcommitとstaging areaの内容が違う場合にはdiffの内容が表示されるので
 git commitでcommit messageを入力してcommitを作成。

 Branches
 今までのところ、各commitは直線上の履歴を作りながら前のcommitの上に作成されてきた。

 今度はあなたが複数のバージョンに枝分かれするcommit履歴を作りたい場合を見てみよう。

 直線型の変更をすることは、単にバグを修正したり、新機能を追加したり、ドキュメントを更新するには
 十分理に適っています。
 でも、まだ動作するかどうか分からない試験的な機能を試してみたい、
 だけどあなたは友人に何に取り組んでいるのか尋ねられた時に、友人に見せるための動作するデモを持ちたい。
 あるいは、イタリア語を勉強していて、ネイティブ言語バージョンは完全に残したままで、
 あなたのプロジェクトのイタリア語を話す人用バージョンを作りたいかもしれない。
この場合には、実際に2言語間を切り替える設定を作りたい。

こういう状況を容易にするために、gitはcommitのラベルを作成することを許可している。

これらのラベルのことをBranchesと呼ぶ。

先ほどの例だと、3つのbranchがいるでしょう。
第一にmaster。masterは大抵のGit repositoryでメインbranchに与えられる名前で、
repositoryを新規作成すると必ずGitはmaster branchをあなたのために作成します。

もう一個のbranchはItalianでもう一個はexperimental、或いは省略してexp branchにしましょう。

前回のレッスンで古いcommitにcheckoutした際、'detached HEAD'メッセージが表示されたのを
覚えていますか？
基本的に、あの時点で、あなたはbranch名のラベルが付いていないcommitを見ているよとGitは警告しました。

今までは、あなたは、detached HEAD状態か、Gitがあなたのために作成したmaster branchにいました。

発音出来ない文字の羅列というよりはむしろ、上手く行けば人間が読めるようなbranch名を除いて、
以前にcommitをcheckoutしたのと同じ様にbranchをcheckout出来ます。

もしbranchをcheckoutしてから、commitを作成すると、branchのラベルは自動的に新しいcommitに
更新する。そのbranchもまたcheckoutされたままなので、再びcheckoutする必要はない。

これが今までbranch upについて何も知らなくても、あなたが何とかmaster branchに留まった理由です。

用語の問題で、branch上の直近のcommitをbranchの先端にいると言う。
一つのcommitに複数のbranchラベルを付けることは出来るが、commitの新規作成はあなたがcheckout
したブランチを更新するだけで、その他は放置します。

2つのbranchを1つに結合する方法がないのかと思うのは当然で,その2つのbranchが分岐したので、
exp branchの試験的機能が遂に動作して、main branchが進んでいるとします。

2つのcommitを結合する過程はmerging(融合、結合)として知られていて、この先のレッスンで
それにも取り組みます。
まずbranchの作成とbranchのcheckout,branchへのcommitに慣れましょう。

git branch
branchを新規作成して表示するのにgit branchコマンドを使用する。
引数無しでgit branchを使用すると、今いるbranchが表示される。
表示されたbranch名に*が付いているのが現在checkoutしたbranch
もし、変更を加えると、更新されるのが＊の付いてるbranch

git branch branch名
引数にbranch名を与えると、そのbranch名のbranchが新規作成される。

更新されるbranch=*のついてるbranchを切り替えるには、
git checkout branch名

What are some situations when branches would be helpful
in keeping your history organized?
How would branches help?

履歴の整頓するのにbranchが役立つのはどんな状況がありますか？
branchはどう役に立ちますか？

試験的機能を追加したりデモ動作を試したい、外国語のバージョンを追加したいといった時。
mainのbranchはmasterとして残したまま、他のバージョンをbranchで分岐させることによって
プロジェクト全体に影響を与えることなく取り組める。

branchはcontext switchingのように使う。文脈切り替え。

branchを他の人々と働く際に物事を整頓しておくのにも使いたいと思うかもしれない。
もし、あなたと協力者全員が同じbranchで変更したら、同時に別々の機能に取り組むのは容易ではない。
人々が一緒にプロジェクトに取り組む一般的なワークフローは、各機能やバグフィックスのbranchを
新規作成することを含んでいる。
このように、複数の人が同時に変更に取り組んだら、各自が休憩の後で仕事を続けるために、
branchをcheckoutすることが出来る。
それらの下に変更することを気にせずに。

そして、新機能かバグフィックスが一旦完了したら、作者=authorはmasterを更新してbranchの先端を
指すようにすることも出来る。
或いは、その間にmasterに変更があったら、Gitとmerge機能を使用して、それを現在のmasterと結合出来る。

mergingの詳細は後で説明する。

asteroidsに宇宙船でcoinにタッチしてコインを集める新機能を追加する。

git checkout coinsでbranch名coinsにcheckoutしてテストプレイしてフィードバック。

Branch coins set up to track remote branch coins from origin.

remote branchは自分で作成したbranch以外のbranchを意味する。

git log --graphコマンドを使うと、Gitはbranch構造を可視化してくれる。
フラグ--onelineを追加すると出力を短くして見やすくなる。
どのbranchを可視化したいのか引数として渡す必要がある。
git log --graph --oneline master coins

各commitは自分の親commitを分かっている。commitが作成された時にcheckoutした参照データを持っている。
もしcommitを作成した時に、branchにいたとすると、それはまだbranchの先端にあった
commit IDを格納するだけです。
commitはbranch名は気にしません。branch自身だけがbranchの位置について記録します。
Gitによってどんな情報が実際に記録されているのか明らかにするためにダイアグラムに
親commitを示す矢印を付ける。これはmergingに取り組むときに重要になります。

concept of reachability 到達可能性の概念

branch aとbranch bがある。各branchでgit logを実行すると、branch bのlogは
どのcommitが表示されるか？

さあ、branchと到達可能性について分かりました。
前に見た'detached HEAD'メッセージの全容を理解するのに、知っている必要のあることは全部知っています。
'detached HEAD'メッセージが表示されるのは、branchではなくcommitにcheckoutした時です。
HEADは現在のcommitを意味しています。
Gitはまず、you can look around(見回して),make experimental changes and commit them.
試験的な変更をしてからcommitしてと表示する。
gitのhistoryは非直線型もあり得るとわかっています。それでもし、変更をcommitすると、
HEADは今あなたが新規作成したcommitに更新される。

次に、gitはyou can discard any commits that you make in this state without impacting
any other branches.と表示する。
あなたは他のbranchに影響を与えることなくどんなcommitでもこの状態で破棄できる。

このcommit(一個だけどのbranchからも離れている)はどのbranchにも含まれていないので
git lockに表示されない。それは到達不可能です。ここで変更されたことは、どのbranchにも
表示されません。そして、実際のbranchにcheckoutすると基本的に、そのcommitは存在しないかの
ようになる。

if you want to create a new branch to retain commits you create,
you may do so by using git checkout -b new_branch_name

もし、あなたが作成したcommitを保持するための新しいbranchを作成したいなら、
git checkout -b 新branch名
を使って出来ます。

git checkout -b 新branch名は2つのコマンドを実行することに等しい。
第一はgit branch 新branch名
第二はgit checkout 新branch名

この一連のコマンドは新機能を作成したりするときに頻繁に使うので、ショートカットがあるのはいいですね。

さっきの一個だけ離れたcommitにいる時に、一連のコマンドかショートカットを実行すると、
そこに新branchが作成されます。その後のcommitはそのbranchに作成されます。

最期のHEAD is now atは、どのcommitに今いるか、どこに作成しているか、をcommitIDの省略型で知らせている。

How do the diagrams help you visualize the branch structure?
ダイアグラムはブランチ構造を可視化するのにどう役立ちましたか？

branch上のcommitには親がいるので到達可能性がある。
到達可能性のないcommit=detached HEADは事実上存在しないかのようになてしまうが、
detached HEADにいる間にgit checkout -b 新branch名か
第一はgit branch 新branch名
第二はgit checkout 新branch名
を実行すると、そのcommitは保持される。

さて、複数のbranchから変更を1つのversionに結合するやり方を見てみましょう。

coin branchが完了したので、その変更をmaster branchと合体させたいと思います。
その間、master branchに何の変更もなければ、masterとcoin branchが分岐したcommitまで
戻って、ラベルを今いるとこ(coin branchの先端)に更新すればいいだけ。

しかし、master branchに変更が加えられたので、何とかしてmaster branchとcoin branchを
結合する必要があります。そして両方のbranchから全ての変更を含んだ一個のversionを作成する
必要があります。

 gitは実際にmaster branchを自動でcoin branchと結合出来て、かなり感動的です。

 これがどう動作するのか理解するために、最初に単純な例を見てみましょう。
 同じファイルの2つのコピーをJakeとRachelという2名の人が独立して編集しているとします。
 一日の始めに、彼らは2人とも同じversionのファイルからスタートします。
 一日を通じて、彼らはそれぞれ変更を加えます。多分、行を足したり削除したりして。
 一日の終わりに、ファイルのJakeバージョンは、何行かコンテンツを含んでいます。
 それをB,D,Eと呼びましょう。もちろん現実では、これらはコードだったりレシピの指示かもしれません。
 でも今は特定のコンテンツについて考えたりして手こずらないで、ファイルのバージョンを結合する
 やり方に集中出来るようにアルファベットの記号を代わりに使います。
 同様にRachelのバージョンも何行か含んでいます。A,B,C,Dです。
 さて、JakeとRachelは彼らの2つのファイルを結合して両方の変更を取り込んだ1つのversionに
 したいとします。
 各行について、あなたはそれが最終的なファイルに存在するべきと思うかどうか。
 もし、その行が間違いなく最終ファイルに含まれると思えばYes.
 間違いなく含まれないと思えば、NO,今あなたが持っている情報からではこれを想像出来ない場合は
 Unknownを入れなさい。
　これは難しいクイズなので、最初の挑戦で正解にならなくても心配しないで。
 ベストを尽くして、各行は独立していることについて考えて。

 あなたはRachelのファイルにA行があるから、最終ファイルに含めるのが安全と考えたのかもしれない。
 しかしながら、JakeはA行を削除したのでA行が彼のファイルに含まれていなかったらどうする？
 あなたが意図的に削除した行が復活するのは、イライラするでしょう。

 あなたはJakeのファイルにA行が無いから、最終ファイルに含めるべきではないと考えたのかもしれない。
 しかしながら、Rachelが一日かけてA行を追加していたらどうする？

 両方のファイルにある同一行は最終ファイルに含まれる。
 両方のファイルから削除された行は最終ファイルに含まれない。
 片方のファイルにだけある行が最終ファイルに含まれるかどうかは分からない。

 RachelのファイルはA行がある。Jakeのには無い。こうなる場合は何通りかある。
 オリジナルのファイルにA行は無かったけど、Rachelが追加したかもしれない。
 その場合には、私達は本当にA行を最終ファイルに欲しい。
 しかしまた、オリジナルのファイルにA行があったけど、Jakeが削除したかもしれない。
 その場合には、最終ファイルにA行を含めるべきではない。
 あとで何時でもA行を削除できるのだから、A行を含めるのが一番安全と思うかもしれない。
 でも、このアルファベットの記号はコードを表しているかもしれないのだから、削除した行を
 また追加するとバグを起こしかねない。
 だから、これ以上の情報が無いとAが最終バージョンに含まれるか含まれないのか分からない。

 この例には、最終ファイルに含まれるのかどうか本当に分からない行が何行かありました。
 何故なら、その行は一人によって追加されたか、もう一人の人に削除されたかで、どっちがどっち
 か分からないからです。

 この問題をどうやって解決しますか？
 ファイルがその日の最初にどんなふうに見えたか知ることは間違いなく役立ちます。
 もしオリジナルのファイルがこんな風に、A,B,D行あったら、
 これらのunknownな行を最終ファイルに含むのか含まないのか決定できますか？
 もう一度、これは難しい質問です。どうやって私が解くかです。
 JakeのファイルにあってRachelのファイルにはない行は、
 Jakeがその作業を追加したかどうか、或いはRachelが削除したかどうか、またその逆について
 私は見当を付けます。

 1日の始めは、A行がありました。RachelのファイルにはまだAがあるので、彼女はA行に関して
 何もしませんでした。しかしJakeのファイルにA行はありません。つまりJakeはA行を削除したこと
 を意味します。なので、私達はA行は最終ファイルに含めません。

 1日の始めにC行はありませんでした。Jakeのファイルにもありません。でもRachelのファイルには
 C行があります。彼女がC行を追加したことがわかります。なので私達はC行を最終ファイルに含めます。

 E行も同じです。一日の始めにE行はありませんでした。でもJakeのファイルにはあります。
 JakeがE行を追加したことがわかります。私達はE行を最終ファイルに含めます。

今は、merging戦略が単純なファイルにとってどんなふうに見えるか実感があるでしょう。
あなたに2つのbranchを一緒にmergeするのを許可するために、このタイプの戦略をGitがどのように使用するのか
見てみましょう。

今すぐに、私は自分のcoin branchとmaster branchが結合したバージョンを作成したいとします。
もしGitにある全部がこの2つのcommitだったら、それらを一緒にmergeするやり方は分からないでしょう。
ちょうど、さっきJakeが行を追加したのか、Rachelが行を削除したのかわからなかったように。

幸運にも、Gitはまたコードが2つのbranchに分岐する以前はどんなふうだったかということも
記録を取っている。

これはRachelとJakeが一日の始めに持っていたファイルに類似しています。
この3つのcommit(分岐点のcommitとcoin branchの先端のcommitとmasterの最新より1個前のcommit)
を使って、Gitはあなたが以前使ったのと似たような戦略で2つのbranchの結合バージョンを作成出来ます。
commitはGitの基本的なブロックですので、この2つのbranchの結合バージョンもまたcommitであることは
あなたにとって、そんなに驚きではないかもしれない。
しかし、この新しいcommitの親commitは何ですか？
結合commitを作成するのにGitを使用する時、その結合commitは両方の親commitについて情報を記録する。
なので、私は矢印を両方に追加する。
coins branchからmaster branchにコンテンツを取得することが、このmergeのゴールなので、
私はこの新規commitをmaster branchの先端にしたい。master branchは最新にアップデートされた
branchなので。
Git実践者はこのプロセスをcoins branchをmaster branchにmergingするとよく言う。

mergeのあとで、master branchは以前に加えられたものにcoins branchからの変更をプラスした
全変更を含みます。

私が依然、古いcommitにアクセス出来るのを除けば、coins branchからの全変更と一緒に
新規commit作成するようなものです。

もし我々がこの時点、コインbranchの最後の時点、そしてマスターbranchの最先端の時点にコミットする時でのファイルの状態を取った時に我々が見るものは異なるということに留意してください。

それがする事の全ては基本的にmasterをcoins branchを同じ状態にセットすることだが、それが我々がしたいことではありません。
我々はこれらの変更を全部、同様に所持していたい。一旦2つのbranchを成功裏にmergeすると、我々は気軽にこのコミットに照会する必要はもう無くなるだろう。我々はそれにmaster branchを通じて達することができます。
だから、一旦mergeすると、我々はcoin branchを削除することが出来ます。
我々がbranchの削除について話す時は、そのラベルを削除することを意味していることに留意してください。
commitは履歴の中に依然として存在しています。
しかしながら、もし、そのcommitに達することができるbranchが無かったら、branchを削除することは
効果的にそのcommitを破棄します。
だから、もしcoin branchを最初にmergeしないで削除したら、あなたは本質的には、これらのcommit全てに達することがでなくなるので、これらのcommitを見捨てることになります。
merge commitを作成した後に、もしmaster branchでgit logを実行したらどのcommitが含まれると思いますか？
隣にチェックボックスがある各commitに、それが含まれるか含まれないかチェックしてみましょう。

もし、あなたが、どんな順番でこれらのcommitがリストに入るのか疑問なら、それらはtimestampによって分類されます。

隣にチェックボックスがないcommiteも含め、これらのcommit全部がlogに表示されます。
あなたが全部のボックスにチェックを入れるのがちょっと退屈だと思ったので。

一方このcommit含まれません。なぜならば、このcommit(masterの最先端)から到達不可能だからです。
あなたは、2つの通り道(branch)があるので、どんな順番でGitがこのcommitを表示するか不思議に思ってるかもしれません。
答えは、commitはそれが作成された時間で分類される、です。
なので、2本のbranchからのcommitは交互配置で表示されます。
さて、キャロラインがあなたをエスコートして実際にmergeとbranchの削除をします。

サラ、ありがとう。さて、私はcoin branchとmaster branchを一緒にmergeしたいです。
mergeした後で、私はmaster branchを更新して、merged versionとして指定したいです。
それで、もし私がまだmaster branchをcheckoutしていなかったら、今check outします。
ちょっと確認します。そして、はい、私は既にmaster branchにいますね。
git merge master coins
を2本のbranchのmerged versionを作成するために実行します。
Enterを入力すると、私のエディターがpop upしてmerge commit用のcommit messageがタイプできます。
その他のcommitとは違って、これはデフォルトcommitメッセージが入力済です。Merge branch coins.
これは変更したければ変更出来ます。でも私が2本のbranchをmergeしたと分かりやすくするために、
このままにしておきます。なので、私はこのままにしておきます。
そしてgitはmergeしてgame.jsファイルが変更されたことを知らせてくれます。
もしgit logを実行すると、merge commitが見れます。
さて、それが動作するかテストに進みましょう。
もし動作したら、コードを実行したら色とコインの両方が見れるでしょう。
ええ、私は色とここにコインがあるのが見えます。どうやらmergeが正確に動作したようです。
あなたはコインが他のゲームのようにカラフルではないと気づいたかもしれません。それは正しいです。
Gitはあなたが行った小さな変更だけmergeします。そしてこのコインを加えるコードは非カラフルバージョンを加えました。
さあ、再びgit logを実行してみると、私はまたmerge commitと私とDougによって加えられたこれらのcommitを見られます。そしてまた、私とDougのcommitの間にSarahによるcommitもあります。
commitはそれが作成された時間で分類されるので。
さて、これは面白い副作用をgit diffに引き起こします。
私がこの2つのcommitのdifferenceを見たいとしましょう。
私はそれが出来ますし、その2つのdiffernceが見れるでしょう、しかし、このcommitはこれのparentではありません。
だから私はこのcommitによってもたらされた変更だけ見ることは出来ません。
試してみましょう。ご覧のように、このdiffにはかなりの数の変更点があります。
でも、実際には、このcommitの変更はほんの少しでした。このcommitによる変更点だけ見るには、そのparentに対して
diffを実行しなければなりません。
でも、どうやったらそのparentが分かりますか？
さらに、gitはgit showあるcommitにより、どんな変更がそのparentに対してなされたのかというコマンドを含んでいる。
なので、実際にそのparentが何か知らなくても私はこのcommitとそのparentのdiffを見ることが出来ます。
今度は、ずっと小さなdiffですね。
coin branchはもう必要ないので、私は
git branch -d coins
コマンドを使って削除しようと思います。
dはdeleteを意味します。
これはbranchの中のcommitは削除しません。単にラベルだけ削除します。
それはcommitを見つけにくくするかもしれません。
でも、これらのcommitは今やmaster branchから到達可能なので、問題ありません。
gitが私がbranchを削除したことを知らせてくれているのがここに見えますね。
merge commitの作成を練習するために、もし、私と一緒にやっていなかったら私のステップを自分のPCで繰り返して見て下さい。
オプションとして、もし興味があれば、コインを固体と黄色にする新しいcommitを導入することも出来ます。
でもこれはオプションなので、JavaScriptの経験は要求されません。
もし、コインを固体と黄色にしたければ、両方のbranchによって何がコードにもたらされたか見るのに
git diffとgit showを使うことをオススメします。
その他の点では、もしあなたが好奇心があれば、解答ビデオにこのcommitの作り方が含まれています。

自分のPCでbranchをmergeしましたか？正しいオプションを選択してください。
もし、コインを黄色にするやり方を見たければ解答ビデオをチェックしてください。


coins branchをチェックアウトする。
もし、あなたがcoins branchをチェックアウトしてない場合は、coins branchに参照出来るようになる前に
今git check out coinsのコマンドでチェックアウトする必要があります。
それが完了したら、チェックアウトしたままにしておくか、mergeを完了するまえに他のbranchにチェックアウトするか
決定します。

git mergeに関する注意
git mergeはまた、現在チェックアウトしているbranchもmerged versionに含めます。
だから、もしあなたがbranch1にチェックアウトして、
git merge branch2 branch3
を実行するとmerfed versionはbranch1をbranch2とbranch3同様に結合します。
それはつまり、あなたがbranch1からの変更をそのmergeに含めたくないとは考えにくいので
branch1のラベルはmerge commitを作成したあとで更新されるからです。
この理由により、あなたは常にmergeしようと計画している2本のbranchのうち1本に、mergeする前に
チェックアウトすべきです。2本のうちどちらにチェックアウトすべきかは、あなたが、どっちのbranchラベルを新規commitに差し向けたいかということ次第です。

チェックアウトされたbranchは常にmergeに含まれるので、あなたが2本のbranchをmergeする時はコマンドラインで
git mergeの引数としてbranch名を両方指定する必要はないのでは？と思うかもしれません。
もしあなたが、branch2をbranch1にmergeしたいとして、あなたは単にgit checkout branch1として
次にgit merge branch2とタイプします。git merge branch1 branch2とタイプする唯一の理由はどっちのbranchをあなたがmergeしようとしているかあなたに思い出させやすくするためです。

また、2本のbranchがmergeされるので、コマンドラインに入力された順番は重要ではありません。
キーは、git mergeは常に、特定されたbranchを現在チェックアウトしているbranchにmergeしてそのbranchのために
新規commitを作成するということを覚えておくことです。

Merge conflict マージの衝突
もしこのようなメッセージが表示されたら

Auto-merging game.js
CONFLICT (content): Merge conflict in game.js
Automatic merge failed; fix conflicts and then commit the result.

あなたがmergeを開始した時に、あなたのファイルはキャロラインのファイルと同じ状態ではないということです。
これを治すには、以下の手順を完了してください。
1.あなたがmergeを開始する前の状態にファイルを復元します。 git merge --abort
2.あなたおファイルの状態をダブルチェックします。もしmaster branchにチェックアウトしている時にgit logを
実行すると、あなたはキャロラインの"Add color"commitが最新のcommitの次に見えて、最新のcommitはbullet bugを修正したあなたのcommitです。
もしgit diffをあなたのcommitとキャロラインのcommitに使うとあなたのcommitは424行目にthis.delayBeforeBullet = 10; があります。この行は下の行と同じレベルに(TAB無し)スペースだけ使って
インテントされていてその行はその後ろにスペースがありません。
3.あなたのファイルが正常に戻ったら、あなたの変更の新規commitを作成します。
4.mergeをもう一度試してみましょう。

Merge conflict マージの衝突（WindowsとUnixシステム間の改行文字）
背景：私達がキーボードの"Enter"キーを入力すると、私達は常に新しい行が存在すべきであることを指す不可視文字をテキストファイルに挿入しろとPCに指示しています。
Unixシステムは"ラインフィード”文字かLFか\nと呼ばれる文字を加えて、Windowsシステムは2文字、"キャリッジリターン”と"ラインフィード"或いはCRLF,\r\nを加えています。

キャロラインのLFを使用するMac OSXで編集されたファイルなのでLFが挿入されています。
もし、Windowsユーザーがキャロラインのファイルを編集しようとすると、Windowsのテキストエディタはファイルを編集できるように全てのLFをCRLFに変換するかもしれません。Windowsユーザーが自分のファイルとキャロラインのファイルを一緒にmergeしようとすると、merge conflictが異なるLFとCRLF文字によって発生します。

この問題を解決するには、Windowsユーザーはglobal autocrlfの属性をtrueにセットしてください。
git config --global core.autocrlf true

更に詳しい情報はこちら。
 https://help.github.com/articles/dealing-with-line-endings/#platform-all

commitをparentと比較する

キャロラインがcommitをparentと比較するのに使ったのは
git show commit_id

コインを黄色にするには、最初にcolorのcommitで導入された変更を見るためにgit showを使います。
スクロールして下がっていくと、Shipの中に、colorがnavyとsolidがtrueに設定されているのが見えます。
同様にAsteroidの中に、colorがlightgrayでsolidがtrueに設定されているのが見えます。
それは多分、coinオブジェクトにこれと同じような行を追加すべきだということを意味しています。
次に、私はcoinが導入される前の最初のcommitと最終的なcoinのcommitを比較したいです。
私はそれらのIDを
git log --graph --oneline
を使用して見つける事ができます。
そして、git diffを使って、ここにあるcoin branchの前の最後のcommitと、ここにあるcoinの最新のcommitを
比較します。
そして少しスクロールで下がると、沢山の変更がありますが、coinがここで導入されたのが見えます。
そこでgame.jsファイルを開いてcoinを検索します。
そして、正確な場所を見つけたら、行を追加します。
this.color = 'yellow';
this.solid = 'true';
そしてファイルをセーブして動作するかどうかチェックしてみます。
ここに黄色いコインがあります、上手くいってますね。
そこで、git diffを使って自分の変更をダブルチェックします。
そしてgit add game.jsで追加してgit commitでcommitします。
私はcommitメッセージにMake coins yellowを使用します。

評価:2本のbranchをマージする
さあ、あなたはbranchをマージするGitの使い方を学びました。以下の質問とあなたの考えをreflection fileに追加してみましょう。

2本のbranchを一緒にマージした結果はどうでしたか？なぜ我々はそれを図に、私たちのやり方を表しているのですか？

2本のbranchをマージすると、各commitの作成時系列に並んで1本のbranchになって、新規merge commitが先端に作成された。
Gitによってどんな情報が実際に記録されているのか明らかにするためにダイアグラムに親commitを示す矢印を付けた。


また、あなたはファイルの変更をcommitしたいかもしれません。進む準備ができたらNextをクリックして
Sarahが何故、この自動mergeプロセスがいつも出来るとは限らないのか、そして何が代わりに起こるのかを説明してくれます。

OK,あなたは今成功裏にGitを使用してbranchをマージしました。
この時点では、あなたはGitがいつも自動でbranchのmergeの仕方を決定してくれるのかどうか不思議に思っているかもしれません。
簡単な例を見てこの事について考えてみましょう。この例では、丁度最後の1つ、オリジナルファイルは数行、A,B,Dを含んでいます。これら(A,B,Dという記号)は、単なる行の代役で、コードの内容自体ではありません。
そこで、前の例のように、JakeのファイルとRachelのファイルは一日の終わりには少し異なっています。
今度は、一日の終りに、JakeのファイルはA行、B'(Bプライム)行、D行を含んでいて、B'は単にB行の変更済バージョンを
意味しています。
そして一日の終りにRachelのファイルは、A行,B"(Bダブルプライム)行、もうひとつのB行変更済バージョンですが、Jakeのと同じではありません、それからD行を含んでいます。
もし、これについてもっと具体的な用語で考えるのが役立つならば、このファイルをレシピと想像する事ができます。
そして、そのB行はオーブンを華氏375度に余熱する指示する行です。
そして、B'は、例えば、オーブンを400度に余熱する指示をします。
そしてB"は350度です。

繰り返しですが、この内容は何でも取り得えます。

最後の演習でやったように、各行について最終バージョンに含まれるべきか含まれないべきかどうかを考えてみましょう。
もし含めるべきならyesにマーク、含めないべきならnoにマーク。
そして、十分な情報を持っていないと考えるならば、unknownにマーク。

それでは、A行とD行はオリジナルファイルに存在していました。そして両方共JakeとRachelのバージョンにまだあります。
なので、それらにはyesをマークします。
さて、全てのBについて考えましょう。JakeとRachelの2人とも、恐らく彼らがその行に行った変更に理由があるのでしょうが、私達にはどっちが正しいのかわかりません。
それらのうち2つは、どちらを最終バージョンに入れるか一緒に議論する必要があるでしょう。
B行自体に関しては、JakeとRachelの二人共この行を変更したので、明らかに削除されるべきだと主張できます。
また、それらの変更を議論した後で主張することも出来ます。
彼らは結局、オリジナルのままにしたいと決定するかもしれません。
これらは両方とも合理的な解答です。注意すべき重要な事は、どちらのBのバージョンが最終ファイルにあるのか
我々は確信していないということです。

この例では、もしB'とB"がBの変更済バージョンなのか、もし、ユーザーが丁度B行を削除して同じ場所に全く新しい行を書いたのかということをどうやってGitが見分けることが出来るのか？

この種の事を解明することに多大な努力を費やすよりも、Gitは行が異なっていて、ここから進むということだけに注意します。
それでは、Gitはmergeの衝突があるのか無いのか分かっているのか？
以下の2例を考えてみましょう。
両方の場合とも、私達は同じファイルの2つの同一コピーから開始します。

最初のケースは、2人の違う貢献者が新機能をファイルの最下段に追加します。
これらはお互いに干渉しない異なった機能で、お互いに関係がありません。

しかしながら、第二のケースは2人の違う貢献者が同じ機能を異なった実装と異なった名前で追加します。

最初のケースでは、あなたはかなりはっきりと、両方の機能を含めたいと思うでしょうが、
第二のケースでは、あなたは、その機能の1バージョンだけ欲しいでしょう。恐らくよりメモリ節約するか高速か、
あなたが何を求めているか次第です。

しかし、Gitはこの2つのオプションを本当に見分けることが出来ません。
これを行うには、かなり洗練された機械学習が必要でしょう。
そして、これは一つの有り得るシナリオです。
Gitをあなたが自動mergeしたい有り得る全てのケースを解明できるほど賢くするのは、大事業です。
なので、代わりに、もしあなたが同じ普通の場所に変更がある2つのcommitを一緒にmergeしたら、
作者はそれを知りたいと思って、どちらの変更を保存するか見当を付ける機会を持つだろうとGitは想定します。
とにかく不明瞭なことがあった時はいつでも、ユーザーに衝突の解消の仕方を聞くという、この決定は、コンテントに関する専門家としてあなたには明らかに明快であるように見える状況に至ります。
しかし、Gitは兎に角、あなたの注意を引きます。
これはイライラしますが、Gitが何の意味もなく、恐らくコンパイルも実行もされない奇妙な変更の集合体に至る推測を頻繁にしようとするよりもずっといいです。


イージーモードの更新
イージーモードのブランチが作成されたので、マスターは更新しました。この場合にはイージーモードのブランチに含めるかもしれないコインの追加があります。一般的に、もし、あなたが実験的なブランチか新機能に取り組むのにブランチを作成するとあなたは定期的にマスターをそのブランチにマージするは非常に一般的です。マスターは通常、公式ヴァージョンを含んでいるからで、マスターへの変更の全てを含めるために実験的な変更を使用するのが普通です。

ダイアグラムの以前のヴァージョン
これが、今現在の履歴がどう見えるということです。

更新されたダイアグラムを描く

あなたがもし、マスターブランチをイージーモードブランチにマージしたら、その後、履歴はどんなふうに見えるでしょう？
あなたが一番好きな方法でちょっと新しい履歴を描いてみてください。
鉛筆と紙を使いたいかもしれないし、git log --graphの出力のようにテキストファイルに*と-を使いたいかもしれないし、オンラインのダイアグラムツールgliffyやyUMLを使いたいかもしれません。
書き終わったら、解答を見てSarahのダイアグラムと較べてみましょう。

マージするとcommitを新規作成することを思い出して下さい。なので、ノードをここに足します。
マージcommitは複数のparentを持っています。この場合、これらのparentはmaster branchの流れの先端と
easy-mode branchの流れの先端になるでしょう。私達はイージーモードを更新したいので、そのラベルを新規commitに移動させたいです。
次に、Carolineが実際にmerge nodeをコマンドラインで作成するプロセスを案内します。

Sarahありがとう。
それで私はまだゲームの公式バージョンは標準の難しさが欲しいので私はmasterに自分のゲームのeasy modeを含めたくないのです。
しかし、私は本当にmasterからの最新の変更を全てeasy mode branchに含めたいです。
これをするには、まず最初にeasy-mode branchにcheckoutします。
それで、そのeasy-modeは私が変更を加えるといつでも更新されます。次に私は
git merge master easy-mode
を実行します。
さて、gitがgame.jsにmergeの衝突があったと警告を出しました。
これは、masterとeasy-modeの両方のbranchがgame.jsの同じ部分を変更したことを意味しています。
ちょうど、RachelとJakeが二人共、同じ行を変更したみたいに。
Gitはどっちを保存するのか知る事ができます。
それで私はその衝突を解決しなければなりません。
衝突を解決するには、game.jsを開いて、衝突が起きた場所を見つける必要があります。
さて、gitはこれらの特別な行を用いて衝突を表現します。なので、私は行中の小なり記号の束を検索することで、いつもそれを見つける事ができます。
スクロールして下を見てみると、これらの行が画面を3つのセクションに分けているのが見えます。
一番上のセクション、HEADのマークがついてるのが私のコードです。一番下のセクション、masterのマークがついてるのが
今現在のmasterのコードです。そして真ん中のセクションが両方のbranchが変更したオリジナルのバージョンで、
gitはcommon ancestor(共通の祖先)と呼びます。
さて、mergeの衝突を解決しようとする時は、まず最初にすることは、両方のbranchがどんな変更を加えたのか理解しようとすることです。
真ん中のセクションと一番上のセクションの違いは、私がeasy-mode branchで加えた変更を示しています。
もし、私がその変更が何だったのか忘れたら、数分使って比較して　その違いがここの3を2に変更したということを思い出します。
真ん中と一番下のセクションの違いは、masterで加えられた変更を示しています。
そして、これはSarahが加えた特別な変更のせいで起きました。
mergeの衝突を解決するとき、変更の1セットが私によって加えられて、その他は他の誰かに加えられているのが非常に一般的です。
それで、私はその人に話しに行く必要があります。でも最初に、私はいつも彼らが加えた変更を見て彼らが何をしようとしているのか理解しようとします。
ここは、Sarahはこのコードの全セクションをbreakIntoFragmentsという関数のコールで変更したように見えます。
さて、それは多分、彼女はこの関数を作成して、このコードをこの関数に移動したことを意味していますね。
コードをより理解しやすいパーツに分解してもっと読みやすくするのは非常に一般的なやり方です。
さて、私は彼女が単にそのコードを移動しただけなのか、他の何かを変更したのか見るために彼女が書いたこの関数を見つける必要があります。
私はその関数を探すことは出来ますが、この場合、ここの丁度上にあるとわかります。
さて、この関数は両方のバージョンにあるようです。
この関数の内部に特別、mergeの衝突に関する行は無いので。
しかし、実際に、この変更が衝突を作った訳ではないので。
さて、私はこの関数とSarahによって下から移動してきたコードを比較するのに数分を費やした後で、
私はSarahが移動した以外にはコードに何の変更もしなかったと分かりました。
さて、私はどうやってこのmergeの衝突を取っておきますか？
次の画面に、あなたが最終バージョンにあるべきだと思うコードを書きなおして下さい。
これらの特別行を削除することも確認してください。
例えば、私が自分の変更をundoしたければ、私はSarahのコードを残すように、これらの特別行のみならず、
自分のバージョンとオリジナルバージョンを削除するだけです。
代わりに、あなたは私達両方の変更を合併するコードのバージョンを作成すべきです。

この場合、私はこのコードを関数に移動したSarahの変更を保存したいので、私は自分の変更をこの関数に加える必要があります。
それで、私は関数の部分までスクロールで上に戻って、ここの3を2に変更します。
そして、私はすでにそこの変更をしたので自分のバージョンを削除します。
そして私はもう必要ないのでオリジナルバージョンも削除します。
それからgitの特別行も削除します。
私はまた、少しこれらの空行を削除して綺麗にします。そして、breakIntoFragments関数のコールを残しました。
それは各小惑星を3つではなく2つの断片に破壊します。

私は今mergeの衝突を小惑星を2つの断片に分けるという自分の変更を新しいbreakIntoFragments関数に移動することによって解決しました。
しかしながら、私はまだその衝突が解決されたことをgitに知らせる必要があります。
私はその解決をcommitすることによってこれが出来ます。
最初に私はファイルをセーブします。次にコマンドラインに戻ってgit statusを実行します。
今度はgame.jsが単にmodifiedと表示される代わりに、gitはファイルはboth modifiedと表示しています。
それはつまり、両方のbranchがそのファイルを変更したので、衝突があったのです。
でも、私はその衝突を解決したので、私はそのファイルをstaging areaにaddします。
さて、git statusをもう一度実行します。するとgitはAll conflicts fixed but you are still merging.
と言っていますね。
git commitを使ってそのmergeを完了します。そこで、私は、そうします。するとまた、gitは私のためにcommitメッセージをを記入済です。今回は、私がmaster branchをeasy-modeにmergiしたことと、game.jsにconflictがあったことを注意しています。前回のように、私は変更したければ、このメッセージを変更することも出来ます。
でも、このメッセージはこのcommitを良く描写しているので、このメッセージはそのままにしてエディタを終了します。
さて、git logを実行します。新規commitが一個だけ作成されたことに留意してください。
gitはmerge　commitと衝突の解決のcommitを別々に作成しません。その代わり、gitはそれらを同じcommitに入れるだけです。
さて、mergeの衝突の解決を練習しましょう。進んで、自分のpcでmasterをeasy-modeにmergeしましょう。
終わったら、
git log -n 1を実行して、出力をここのboxにペーストして下さい。

-nフラグはgit logがその番号のcommitだけ表示することを意味します。
この場合は1です。

タスクを完了したあとで、これが私のgit log -n 1の出力です。
commitメッセージは私がmaster branchをeasy-modeにmergeしたと明記しています。
そして、game.jsに衝突があったことも。
さて、Sarahのところへ行って、あなたが学んだ新しい概念をコンセプトマップに追加しましょう。

コンセプトマップ：branch,merge

新しいアイディア
あれから、私達は幾つかの新しいアイディアについて話してきました。最大のものは、branchingとmergingです。
branchingとmergingはコンセプトマップのどこに一番フィットしますか？クイズに進んで加えてみてください。

あなたはmergingとbranchingは両方共にcommitと一緒にしなければならないことを知っていますが、
それらのアイディアは、commitとそれぞれ、どんな関係でしょうか。
Branchは実際、commitを参照する単なるラベルなので、私達はこの新しい種類の関係(refer-to)を導入します。
なので、これはbranchです。これが本当に合っているか確認しましょう。
diffは本当にbranch上で動作する関係ですか？はい、そうですね。2つのcommitをdiffできますし、2つのbranchをdiff出来ます。それは基本的に2つのcommitをdiffします。
でもそれは、異なったアイディアの一種です。同様に、git logをbranch上でもcommit上でも実行出来ます。
なので、これはmergeがここに入らなければならないことを意味しています。それではこれを確かめてみましょう。
mergeはcommit上で動作しますか？ええ、mergeは2つのcommitoを取って、それらを押しつぶして一緒にして、新規commitにします。だから、私は「~上で動作する」は非常にいい説明だと思います。

Reflect:自動と手動Merging
さて、あなたはGitが自動でmerge出来ないことがあって、出来ない時に何が起きるかを学びました。
あなたのreflection fileに以下の質問と解答を追加しなさい。

Git mergingを自動でやるのと、いつも手動でやることの長所と短所は何ですか？

あなたは、またファイルへの変更をcommitすることが出来ます。進む準備ができたら、Nextをクリックして、あなたが
このレッスンで学んだツールをJefferyがどうやって使っているのか聞いてみましょう。

自動の長所
自動は楽

自動の短所
自動はconflictでこける。

手動の長所
常に自分でbranchやcommitの状態を把握している、conflictを起こしにくい。

手動の短所
面倒くさい

おめでとうございます。lesson2を完了しました。このレッスンで、あなたはGit repositoryを作成して
初めてそこにcommitを作成しました。
あなたはまた、どんな変更が各commitに入るのか正確にコントロールするのにstaging areaを使うことを学びました。
最後に、あなたはGit branchを使って、あなたのコードの並行するバージョンを維持することを学びました。
そして2本のbranchを一緒にmergeして1つの合体バージョンにする方法も学びました。
次のレッスンでは、あなたのプロジェクトを共有して他の人々と共同作業するためにGitHubの使い方を見ていきます。

それではまた。




 　
