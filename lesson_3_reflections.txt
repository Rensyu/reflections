あなたはもうバージョンコントロールと使いたい時、自分のPCでバージョンレポジトリを作成して改変するGitの使い方を知っています。
あなたはbranchを作成して新機能をトラックするやり方と、あなたの変更を一緒にマージするやり方を学びました。
このレッスンでは、あなたは他の人と変更を共有する仕方と他の人の変更を自分のプロジェクトに持ってくる方法を学びます。
これをやる方法は沢山ありますが、私達はそれらのゴールを達成するために、特別にデザインされた製品であるGitHubに焦点を当てます。
GitHubはgit repository全体を他の人々と共有するのを簡単にしてくれるウェブサイトです。
例えば、ここに私達がUdacityで作成したrepositoryがあります。
このrepositoryはブラウザベースのあなたの冒険物語を作成するソースです。
ここにrepositoryの全ファイルがあります。クリックしてみると、ディレクトリ構造をナビゲートします。
そして私はcommitの履歴を見ることが出来ます。
メインページに戻ってスクロールで少し下に下がってみると、あなたはそのプロジェクトについての情報を見ることが出来ます。
私はまたファイルがコードや物語のようなプレーンテキストだと想定すると直接ファイルの内容を眺めることができます。
GitHubはまた、画像や3Dモデルや地図データのような幾つか他のフォーマットもサポートしています。
このファイルでは、私は物語自体を通してクリック出来て、いくつかの選択を始めることが出来ます。
あなたはここをクリックしていつでもrepositoryのメインページに戻れます。
これはpublic repositoryなので、誰でもこれらの内容を見ることが出来て、変更を提案出来ます。
Carolineと私はこのレッスンでこれがどのように動作するのか詳細に練習するつもりです。
そしてレッスンの終わりまでに、あなたはそれを自分自身に寄与することが出来るでしょう。
これは生きているプロジェクトですので、このページを訪れるまで、物事は少し違って見えますが、
基本は同じです。GitHubはこのプロジェクトのように多くの公共プロジェクトのホームです。
沢山の公共プロジェクトがオーブンソースで、あなたは自分の目的のためにコピーとコードの改変が出来ます。
GitHubはまた、あなたに変更の提案と、変更をプロジェクトの作者に送り返させることが出来ます。
これらのオーブンソースプロジェクトは10人の寄与者しかいないmathquillのような非常に小規模で比較的知られていないものです。あなたはこれを知っているかもしれませね。
いくつかのプロジェクトはPythonのデフォルトで使うインタラクティブシェルよりもずっと便利であるiPythonのようにずっと大規模です。
もう一個の大規模プロジェクトはweb開発を簡単にするframeworkであるBootstrapです。
またHTMLと相互作用するのを簡単にするJavaスクリプトのライブラリであるjQueryもあります。
またAtomもあります。コードを編集するようにデザインされたテキストエディタでユーザーがユーザーエクスペリエンスをカスタマイズすることが出来ます。
これらのプロジェクトは誰でも理論上は貢献できます。もちろん、どんな変更でもプロジェクトを維持管理している人々に受け入れられねばなりません。
しかし、オリジナルの作者があなたの変更を取り込まないことを選択したとしても、あなたは依然として自分自身のバージョンを維持することが出来ます。
GitHubは誰もが公共repositoryを無料でホストして、プライベートrepositoryは有料でホスト出来るようにして、オープンソースを促進することを目指している。　
Udacityを含む多くの企業が彼らのプロプライエタリコードの変更をトラックするのにGitを使用していて、彼らのrepositoryのプライベートコピーをホストするのにGitHubを使用しています。そして開発者が変更を投稿したときに、コードの批評を簡単にしています。
このレッスンのために、あなたはGitHubと沢山交流します。作成、変更、パブリックリポジトリへの変更の提案。
それであなたはアカウントを設定する必要があります。これはとても簡単ですが、あなたは多分、スムースにもう少し複雑なコマンドラインからGitHubと交流するために設定したいでしょう。
あなたはこのビデオのあとで全ての設定の指導を見ます。
さて、あなたはGitHubアカウントの設定を完了して、あなたの最初のパブリックリポジトリを作成する時間です。
すなわち、あなたのreflectionリポジトリをGitHubに置きます。
多くのクラウド型ホストシステムのように、これは、あなたのPCのリポジトリとGitHubでホストされているバージョンの間で同期を伴います。それはあなたがwebサイトで見るバージョンです。
GitHubと交流する時に、あなたが送受信する情報はgit commitの型式なので変更は送信される前にstageに登録されてcommitされます。
私がGitHubリポジトリに作業ディレクトリやstaging areaを描かなかったことにあなたは気付いたかもしれません。
これらは、全てのリポジトリに存在しますが、GitHubリポジトリはGitHubのサーバーにホストされているので、
直接アクセスすることが出来ません。なので、ここでは本当に関係がありません。
あなたのファイルのクラウドホストバージョンと同期する多くのサービスと違って、GitHubを使うときは、
あなたはいつ、どのように2つのバージョンを同期するのか選択する必要があるでしょう。
あなたはこれを、gitがあなたにいつcommitをセーブするのか手動で決定させたのと同様に考える事ができます。
もしGitHubが毎回commitの後で自動的にあなたのローカルバージョンを更新したら、完璧に準備が出来る前に物事を公にすることになります。新機能はよく複数のcommitを要求するので。
それでは、同期は自動で起きないので、私達はどうやってリポジトリのローカルコピーとGitHubでホストされているバージョンを同期しますか？
特に、あなたはどうやって、既存のリポジトリの現況をこれから始めるGitHubに反映することが出来ますか？
あなたはGitCloneと答えたいかもしれません。それは、レッスン1に戻ってGitHubからリポジトリのコピーをローカルに取得するやり方です。
これはかなり合理的な推測ですが、GitHubは直接彼らのサーバーにクローンすることを許可しないことが判明します。
なので、代わりに、まず最初にGitHubに空のリポジトリを作成する必要があります。
今は実際にこれをやらないので心配しないで。重要な部分は、今のところは既存の場所の空のリポジトリと考えることです。
２つのリポジトリの間でデータを同期させるには、gitはリモートリポジトリという概念を持っています。
これは、あなたにあなたがcommitを送受信したいリポジトリの場所を保存させます。
Gitユーザーは良くこのリモートリポジトリのことを単にリモートと呼びます。
あなたはCarolineともうすぐリモートのセットアップの仕方を見ます。でも今のところは、私は2つのリポジトリの間の接続を矢印で説明します。
それでは、どんな種類の交信がリモートと出来ますか？そうですね、あなたはデータをプッシュしたりデータをプルしたり出来ます。私は前にあなたがリモートから送受信するものはcommitだと言いました。
しかし、個々のcommitを選択する代わりに、データを送受信する最も一般的な方法はbranchを特定することによってです。
それで、このリポジトリの場合、そして多分あなたのreflectionリポジトリも同様ですが、私達は
master branchをプッシュしさえすれば良いです。masterの先端のcommitによって全て到達可能なので、あらゆるcommitが送信されます。
それで、あなたがmasterをpushすると、これらのcommitの両方が現れます。
もし、これらのcommitのどちらか一方が、私達がpushコマンドを実行する前に、既にGitHubのサーバーにあれば、
gitはわざわざそれを送信しないでしょう。
もし、あなたが何百、何千ものcommitがある大規模なリポジトリを持っているところを想像して、
毎回、個々のcommitを送信するのは非常に非効率的でしょう。
ちょっとこの概念が理に適っているのか確認してみましょう。
仮説の状況を見てみましょう。もし私がローカルにこのcommit履歴を持っていて、このGitHubはリモートとして設定して再投稿したら、次にbranch aをpushします。どのcommitが送信される必要がありますか？
リポジトリ間のコミュニケーションはcommit履歴のレベルだけで起こるので。ここでは私は両方のリポジトリをcommit履歴を示すだけで描いているということに留意して下さい。
なので、ワーキングディレクトリやstaging areaのどちらもここでは必要ありません。

branch aをプッシュすると、Gitは先端のe53から開始して、遡ってそのcommitから到達可能な全commitを探して、
GitHub履歴にまだ存在しないcommitを送信します。
なので、e53とfd2は両方共送信されます。しかしbranch aから到達不可能なので6b4は送信されません。
それからa3bも送信されません。なぜならば、a3bは既にリモートリポジトリに存在しているからです。
そして、pushした後で、GitHubリポジトリはこのように見えます。

Sarahが言っていたように、私のreflectionリポジトリをGitHubで共有するために、私はまず最初にGitHubにリポジトリを作成します。
これをするには、私は確認します。ログインしているか　このコーナーの私のユーザー名を探して、次に任意の画面上で、
私はプラス記号をクリックしてnew repositoryを選択します。
私はそのリポジトリをreflectionsと名付けて、publicのままにしておきます。
さて、私はそのリポジトリをREADMEで初期化したくありません。もし私が何かコンテントを作成する前にGutHubでリポジトリを作るのなら、私は多分このboxにチェックします。
何故ならば、その方法だと、私のリポジトリは一個のcommitがある状態で開始するからです。
あなたは、commitが無いリポジトリをクローン出来ません。だからこれは時には良いアイディアです。
しかし、私は既に自分のリポジトリに共有したいcommitsを持っています。
このボックスにチェックはしません。
次に、私はリモートとしてこのリポジトリに私のPC上のreflectionリポジトリを追加します。
丁度、私がbranchを見たり作成するのにコマンドgit branchを使うことが出来るように、
git remoteはリモートを見たり作成したり出来ます。
最初に私は現在のリモートのあらゆるものを見るためにgit remoteコマンドを引数無しで実行します。
出力は空です。何故なら、私はまだリモートに何も追加していないからです。
次に、リモートとしてGitHubのリポジトリを追加するために、私はgit remote addを実行して、
私は私が使用したい名前を与えます。
さて、私はここでどんな名前でも使えます。それはGitHubのリポジトリを呼ぶために私がこのリポジトリ内で使う名前です。
もしあなたが一個のリモートを持っているだけならば、それをoriginと名付けるのが普通ですので、私もそうします。
次に私は自分のリモートのURLを与える必要があります。私はそのURLを今reflectionリポジトリを作成したGitHubのページで見つけることができます。
それで、私はそのURLをコピーして、私のコマンドの中へペーストします。そしてEnterを押します。
さて、git remoteをもう一度実行してみると、私はoriginリモードが作成されたのが見えます。
そのURLが正確に追加されたことを確認するために、私はgit remote -vを実行します。
Vはverboseを表していて、gitリモートがより多くの情報を出力することを意味しています。
即ち、それはより言葉数が多く、冗長で詳細になります。
その出力は私がデータをfetchしてくるところと、私がデータをpushするところの両方のURLを表示しています。
殆どの場合、これらは同じURLです。
ここに、私が今ペーストしたのと同じURLが見えます。
さて、私の変更をリモートに送信するために、私はgit pushコマンドを使います。
git pushは2つの引数を取ります。変更を送信したいリモートと、私がpushしたいローカルのbranch名です。
私はリモートをoriginと名付けました。そして私は全変更をローカルのmaster branchで行いました。
だから、
git push origin master
を実行します。
私がgit pushを実行する前に、私は自分のローカルリポジトリのmaster branchで山程の変更をしました。
そして、私のGitHubのリポジトリは空です。git pushを実行すると私のmaster branchから到達可能なcommitの全てをoriginにコピーします。それは私のGitHubのリポジトリです。
デフォルトでは、GitHubに作成されたbranchは私がpushしたローカルのbranchと同じ名前を持ちます。
なので、このbranchもまたmasterと呼ばれます。
さて、私はGitHubのページを更新してみます。そして、私は私の全ファイルが追加されたのが見えます。
私はまた、私がいるbranchがmasterを名付けられたことがここにも見えます。
さて、あなた自身のGitHubアカウントでreflection repositoryを作成してみましょう。
そしてあなた自身のPCからあなたのreflectionsをGitHubにpushしてみましょう。
あなたの新しいreflectionsリポジトリのリンクをフォーラムに投稿しましょう。
次に、ちょっと他の生徒のreflectionsを何人分か読んでみましょう。
あなたはまだ彼らのレッスン3のreflectionsは読みたくないかもしれませんが。
他の人々が言った事を読む前に、もしあなたが彼らについて自分自身として考えると、彼らのreflectionはもっと価値があるでしょう。
一旦あなたのreflectionsリポジトリへのリンクを共有したら、このボックスをチェックしましょう。

SSHのではなくHTTPSのURLをコピー！
1:29でCarolineはリポジトリへのURLをコピーしました。ビデオは間違ってリポジトリがSSHでアクセスされるのに使うURLを表示しています。このコースは生徒はSSHではなくHTTPを使用することを想定しています。HTTPSボタンをクリックして現れたHTTPSのURLをコピーして下さい。それはgit@github.comではなくて、https://で始まります。
もしあなたが、代わりにSSHを使うことに興味があれば、あなたはここの指導に従えます。
https://help.github.com/articles/generating-ssh-keys/
しかし、あなたが既にSSH keyに慣れていない限りお薦めしません。

あなたのreflectionsを共有しよう。
私達はあなたが大胆にあなたのreflectionをGitHubで共有することをお薦めします。もしあなたが、自分の解答のどれにも満足していなかったら、一番良い解決方法はその解答を1個か2個のcommitで更新することです。
前の解答はまだcommit履歴で見ることが出来ますが、時間をかけてあなたの視点を更新することが、学習プロセスの一部です！
あなたの視点の更新を表示するcommit履歴を持つことは、あなたに少しではなく十分に反映されます。

それはつまり、もしあなたが、自分のreflectionリポジトリに共有したくない何かを書いたら、あなたは、あなたがその変更を導入する前にそのcommitをcheckoutすることが出来て、その時点で新しいbranchを作成して、あなたが喜んで共有したいその他の変更を何でも新しいbranchにcommit出来ます。
そして、新しいbranchだけpushすることによって、あなたは自分のoriginal branchをプライベートに保てます。

願わくば、あなたがこのコースの他の生徒によって投稿されたreflectionsを見て楽しんだことを。
彼らのreflectionはあなたのreflectionとどのように違っていましたか？

さて、あなたはGitHubにリポジトリを作成しました。そして、その中にcommitが幾つかあります。
GitHubのウェブサイトで、これがどんなふうに見えるか見てみましょう。
Creage Your Own Adventureリポジトリのように、私はどんなファイルがそのリポジトリにあるのか見えます。
またスクロールで上に戻って、私はcommitsをクリックするとcommit履歴が見えます。
これは、コマンドラインでgit logを実行するのと同様です。
しかし、それはローカルのリポジトリの履歴を表示するのではなく、GitHub上のリポジトリの履歴を表示します。
なので、あなたはGitHubにpushした変更だけが見えます。また、GitHubのWebサイトでプレーンテキストファイルの直接編集と作成が可能です。
たった今、私は自分のローカルリポジトリからGitHubにpushしました。なので、両方とも同じコンテントを持っています。
しかし、私が幾つかコンテントを直接GitHubに追加しようとすると、あなたのローカルのリポジトリには現れていない変更がGitHubで現れた時、何が起きるかあなたは見れます。
実際に、もしあなたがGitHubで直接変更すると、これは起こり得ます。しかしまた、もしあなたが、他のコンピューターからGitHubに変更をpushしても起こり得ます。
或いは、もしあなたのプロジェクトで作業していてGitHubに変更をpushする他の人が人がいても起こり得るのです。
新規ファイルを作成するには、このプラス記号をクリックします。私は自分のレッスン3reflectionのファイルを作成するつもりです。そして私が最初のreflectionプロンプトになるでしょう。あなたはこのプロンプトをすぐに見ることになります。さて、スクロールで下がって、ここに、私はcommitメッセージを入力出来ます。
メッセージは最初のboxに入ります。そしてもし私が自分のcommitのもっと長い説明を追加したければ、私は二番目のboxを使うことができます。でも私はそこは空白のままにしておきます。
さて、画面の右側のCommit new fileがクリックできます。さて私は新規commitが作成されたことが見えます。
レッスン3のためのファイルを作成して最初のreflectionを追加しなさい。
さて私は直ぐにこれらの変更を自分のローカルリポジトリにpullするのをデモします。
なのであなたは付いてこれます。
あなたは次の画面でそれのやり方について幾つかの指導を見ます。

GitHubで変更する
今、あなたはリモートリポジトリの作り方と、そこに変更をpushするやり方を見てきたので、GitHubのウェブサイトを使用して、あなたのレッスン3のreflectionを新規作成して以下の質問とあなたの考えをそのファイルに追加してみましょう。

もし、あなたがダウンロード可能セクションのファイルlesson_3_reflection_prompts.txtから始めるのが好きならば、そのファイルがダウンロード出来ますし、それをローカルでcommitしてGitHubにpushしてあなたの反応をGitHubのウェブサイトを使用して、そのファイルに追加出来ます。

Reflect:リモートリポジトリの使用
以下のreflectionプロンプトを使いなさい。

あなたのローカルでの全作業を保持するよりもむしろ、リモートリポジトリを使いたいのはいつですか？

あなたの変更のcommitが終わったら、Nextをクリックしてそれらの変更を自分のコンピューターにpullするやり方を
見てみましょう。

変更をPullする。

Carolineのリポジトリの２つの異なったバージョン(ローカルとGitHub)がこの時点でどんなふうに見えるかについて
考えてみましょう。
これがCarolineがGitHubと交流する前のローカルバージョンの様子です。
次に彼女はmaster branchをpushしました。そして次に、そのcommitsはmaster branchにあったので、
全て送信されました。なので、この時点で、両方のリポジトリとも同じ履歴を持っています。
次にCarolineがGitHubで直接ファイルを編集して、master branchにコミットしてmasterを更新しました。
なので、これが今我々がいるところです。
彼女のローカルバージョンはリモートのGitHubバージョンから遅れています。
リポジトリを再び同期するには、彼女は自分のmasterをローカルバージョンにpullする必要があります。
これで、新しいcommitがローカルバージョンにもたらされて、masterが更新されます。
さて、私はCarolineに引き渡して、これをコマンドラインで見てみましょう。

Sarahありがとう。さてご覧のように、私が丁度作成したcommitがGitHubのサイトのcommit履歴に表示されています。
しかしながら、私がgit logを実行すると、そのcommitは私のローカルリポジトリには現れていないのが見えます。
ローカルリポジトリに現れるようにするために、私はgit pullを実行します。
私がgit pushを実行した時のように、私はリモートを特定する必要があります。それに私はoriginを名付けました。
Pullするためには、私はまた自分がpullしたいbranchを特定する必要があります。
そのbranchはリモート上のmaster branchです。
git pull origin master

私がgit pullを実行する前に、私はGitHubにpushした幾つかのcommitが自分のローカルリポジトリにありました。
私はまたレッスン3のreflectionファイルを追加して新しいcommitをGitHub上に持っています。
私がoriginリポジトリからmaster branchをpullした時、即ち、GitHubの自分のリポジトリ、それは
GitHubのmaster branchから全部の到達可能なcommitを自分のローカルリポジトリにpull downします。
この場合、私はmaster branchにチェックアウトしていたので、gitはまた私のローカルのmaster branchのラベルをその新しいcommitを指すように更新しました。
さて、これらの2つの名前が同じである必要はありませんが、普通は同じ名前です。
そして、私は再びgit logを実行します。すると、私は今、自分の新しいcommitがローカルリポジトリに現れたのが見えます。
さて、進んで、あなたがGitHubで行った変更をあなたのローカルリポジトリにpullしましょう。
終わったら、次のうち、どれが本当ですか？
.あなたのローカルリポジトリの幾つかの変更はGitHubに存在しない

GitHubにない変更は、あなたのローカルリポジトリにも何の変更もないべきです。
なぜなら、最も最近の変更をローカルリポジトリに加えた後で、あなたはgit pushを実行したので。(だから上は嘘)

.GitHubでの変更の幾つかはあなたのローカルリポジトリに存在しない

同様にあなたはgit pullを最も最近の変更をGitHubで直接加えた後で実行しましたね。(だから上は嘘)
なので、あなたのローカルリポジトリに無いどんな変更もGitHubにあるべきではありません。

.どちらも本当ではない。あなたのローカルリポジトリでの全変更はGitHubにあるし、その逆もある。(true)

代わりに、2つのリポジトリは現在、同じcommitを持っているべきです。(なので、上は本当。)

コンセプトマップ:GitHub,Pull,Remote

前回コンセプトマップを再訪してから、私達は幾つか新しい概念を導入しました。
・GitHub
・git push
・git pull
・remote

私達の新しい概念はどこに入るでしょう？

残された画面の余白は余り無かったので、私達は前のレッスンからこのレッスンで取り上げられて新しい概念のためのノードに追加される新しい概念としっかり絡まっていない幾つかの概念を削りました。

どの概念がどこに属しますか？
以下のクイズに従って、あなたがそれぞれ空のノードに属するを思う概念を書き込んで下さい。
このマップが主観的であることを忘れないで下さい。私達がここに示したマップはあなたの精神的なモデルに正確には適合しないかもしれません。即ち、あなたが概念の間にみえる接続を気楽に描き出して下さい。
そして、あなたのバージョンをフォーラムで共有しましょう。

OK.これらがどこに適合するのか見てみましょう。GitHubから始めます。GitHubはユーザーにGitと交信させるサービスです。私達がこれを表すには幾つか違った方法があります。GitHubがGit上で動作しているかもしれないし、
GitHubがGitを参照しているのかもしれない。
でも私はそれを、GitはGitHubの一部であると表現することを選びました。
さてリモートについて考えましょう。あなたのローカルリポジトリのリモートは基本的に、他のリポジトリへの参照です。
なので私達はリモートはリポジトリを参照している言えるでしょう。また、あなたがリポジトリをクローンする時は、
リモートがあなた用に自動的に設定されます。なので私達はcloneはリモート上で動作すると言えるでしょう。
なので、remoteはここに入ります。
この時点で、残りの2箇所が全く同じ状態であります。両方共リモート上とbranch上で動作します。
なので、私達はこれらを、どちらの場所でも入れられます。
これが本当に合っているか確かめてみましょう。あなたがpushかpullする時は、あなたはどのbranchをあなたがpushやpullしたいのか特定しなければなりません。なので、それは間違いなくbranch上で動作します。
pullはリモートからbranchを取って、ローカルリポジトリに持ってきます。
そしてPushは正反対に、branchを取ってリモートに持って行きます。
なので、これらは両方共同様にリモートで動作しますね。さあ、私達は現時点でのコンセプトマップが出来ました。

Reflect:マニュアル v.s. 自動Pull

さて、あなたは変更をGitHubにpushしてGitHubから変更をpullしました。以下の質問とそれに対するあなたの考えを
reflectionファイルに追加しなさい。

なぜ、Gitに自動であなたのリモートリポジトリと一緒に最新に保たせるよりも、あなたは常に変更を手動でpullしたいのですか？

何でだろう？

あなたは、また、自分の変更をcommitしてpushしたいかもしれません。Nextをクリックして、 もしあなたがリポジトリへの変更を共有したくて、あなたがオリジナルのファイルを変更する権限がなかったら、あなたはどうするのかSarahが調べます。

私達の同僚のLarry,あなたが最初のレッスンで見ました、はレシピのリポジトリをまとめています。
Carolynと私はこのレシピが好きですが、私達はそのレシピをもう少しより私達の味付けに微調整したいです。
そうして私達が友人とレシピを共有できるように。
Larryは私達が変更バージョンを共有することにOKです。しかし、彼は自分のバージョンをそのままにしておきたいのです。
Carolynと私は二人共変更がしたくて、そのレシピを他の人々に見て欲しいし、自分たちのバージョンをGitHubでホストするのは最適です。
私達が話してきたことをするだけで、GitHubでコピーを取得するのは可能でしょう。
まず第一に、私達はLarryのリポジトリを指定して、それを例えばCarolineのコンピューターにクローンします。
これで、自動的にLarryのリポジトリがOriginと呼ばれるリモートとして設定されます。
次に、私達は新しいリポジトリをCarolineのアカウントでGitHubに作成することが出来ます。
そして彼女はこの新しいリポジトリをリモートとして設定出来ます。それは彼女が好きなように呼ぶことが出来ますが、
例えばOur versionにしましょう。
次に私達が前に見てきたように、彼女は変更をリモートにpush出来ます。
そして次に、私はこのリポジトリに同様に貢献したいので、私はそれを自分のコンピューターにクローンして
Carolineのバージョンをoriginとして設定することができます。
これは、かなり複雑ですが、そして、それはまたLarryに彼がオリジナルのリポジトリに行った仕事に何の感謝も与えていません。
誰かが我々のバージョンを見て、Larryのバージョンについて私達が明確にリンクを張らない限り何かアイディアを持つ手段が何もないので。
私達のパートにより少ない労力で同様の効果を上げるには、GitHubにはForkingと呼ばれる機能があります。
これはあなたに最初にそのコードをあなたのローカルマシンにpullさせることなしで、誰か他の人のリポジトリをGitHubに直接コピーさせます。
あなたはクリック1回で、既存のリポジトリをforkして、それをあなたのアカウントの直下に出現させることが出来ます。
次に、あなたの変更を加えるには、ファイルがGitHubで直接編集出来るほど単純でない限り、あなたはコードを自分のコンピューターにpull downしたいかもしれません。ForkはCloneにとても似ています。実際、ForkはGitHubがあなたのために自分のコンピューター上で作成する単なるcloneです。
Forkには幾つか他の副作用があります。GitHubがあなたのリポジトリをforkした人の数をトラックし続けるように。
そしてforkは全てオリジナルにリンクを張ります。それはまたオリジナルのリポジトリに変更を提案して戻しやすくします。
それは私たちはレッスンの後のほうで詳細をカバーします。
それで、Larryのバージョンは既にGitHubにあるので、forkするのはこの場合は非常に理に適っています。
Carolineは彼女のアカウントでfork出来ます。そして私達は各自、私達のバージョンをクローン出来ます。
クローンはオリジナルのリポジトリのことについて、何も知る必要はありません。
あなたのコードのバージョンのための多種多様な方法の間に、関連した概念が沢山あるので、私達は今までのことを全部理解していることを確認したいです。
以下の各ダイアグラムはそれぞれ、branch作成、forkかcloneを表しています。
テキストボックスを使用して、各ダイアグラムによってどの概念が表されているか示しなさい。
Branchは単一のリポジトリで発生します。もちろん、あなたはbranchのpushとpullが出来ますが、
branchを作成する時は、branchを1個の単一なリポジトリに作成することになるので、唯一、その性質に該当するのはこれです。
私達は一本のbranchと、ここに2本目のbranchがあります。なので、これがbranchです。
Cloneは既存のリポジトリを指定して、そのままそっくりもう一個のリポジトリを作成することを含んでいます。
オリジナルのリポジトリは、この場合のように、リモートになりうるので、ここに、私達はGitHubからローカルマシンにcloneしました。
或いは、あなたはローカルリポジトリでさえあなたのコンピューター上の別の場所にcloneすることが出来ます。
私達はこれについてはまだ本当に話していませんので、これは多分少し扱いにくかったでしょう。
これもクローンに大変似ていますが、私達が私達のリポジトリをGitHubからGitHubにクローンしたことを
思い出して下さい。あなたは、それをGitHubに組み込まれたfork機能を使用して出来ます。
クローンが任意の2つのリポジトリで動作するのに対して、ForkはGitHubの文脈内でのみ使用され、既存のGitHubリポジトリを指定して、そのコピーを作成します。

レシピリポジトリをForkするには、最初に私はGitHubでLarryのリポジトリを訪問します。
あなたは、このリポジトリのリンクをインストラクターのノートで見つけることができます。
さて、私はそのページのこの部分にズームして、ここのForkボタンをクリックします。
すると、私のGitHubプロファイルにそのリポジトリのコピーが作成されました。
さて、私が自分のプロファイルを訪問すると、レシピのリポジトリがここに見えます。
今度は、私はこれらのレシピをGitHubのウェブサイトでやるよりも自分のコンピューターで編集出来るようにしたいです。
それで私はまたこのforkをクローンしたいです。レシピは私がどこで編集しようが構いませんが、
もし私がコードを書くとしたら、私は間違いなく自分のコンピューターで編集出来るようにしたいです。
GitHubのページは私がクローンすべきURLをここに載せているので、私はそのURLをコピーします。
そして私のgit cloneコマンドの中にペーストします。さて、私は新しいリポジトリにcdで移動して、
あなたは私がそこにpush出来るようにGitHubのforkをリモートとして追加する必要がある思うかもしれません。
しかし、実際にはあなたがリポジトリをクローンする時には、Gitが自動的にあなたがクローンしてきたリポジトリを
指すリモートを設定します。
私はそれをgit remote -vを実行して確認します。
そして、思った通り、originと呼ばれるリモートがありました。そして、そのURLは私のGitHubのリポジトリを指しています。
最後に、私はSarahが私と共同作業出来るようにしたいので、彼女はこのリポジトリにpushするパーミッションが必要になります。
私は設定から、Collaboratorをクリックして彼女をコラボレーターとして追加します。そして次に彼女のGitHubユーザー名のsalogel42を追加します。あなたはSarahをあなたのリポジトリに共同作業者に追加する必要はありません。
しかし、あなたはあなたのリポジトリにpush出来るようにしたい人を誰でも追加出来ます。
そして、私はAdd collaboratorボタンをクリックします。

さて、LarryのリポジトリをあなたのGitHubプロファイルにforkしましょう。
私はこのレッスンを通じて自分のforkを変更するので私のプロファイルのレシピリポジトリをforkしないでくださいね。
そして、あなたはこれらの変更はしたくないです。
もう一度、あなたはLarryのリポジトリの完全なリンクをインストラクターノートで見つけることができます。
forkを作成したら、あなたのforkをクローンして、git remote -vを実行して、その出力をこのボックスにペーストしてください。

私がgit remote -vを実行すると、私は両方のURLが私のGitHubのforkのURLであるgithub.com/cbuckey-uda/recipes.gitになっているのが見えます。
あなたも自分のforkのURLが見えるはずです。それであなたのユーザー名がここの私のユーザー名の代わりにあります。

新しいレシピを追加しましょう。
あなたのコンピューターであなたの好きなレシピを追加して、master branchにcommitしましょう。

あなたの変更をPushしましょう。
master branchをあなたのforkにPushしましょう。pushのやり方を思い出せないならば、このビデオを見なおして下さい。終わったら、続けて次の画面で異なった時点でどこにあなたのcommitが存在しているのか質問に答えてください。

あなたのcommitはどこにありましたか？
あなたが、git pushを実行する前、あなたが新しいレシピを追加したcommitはどこにあったと思いますか？
同様に、今、あなたはgit pushを実行しましたが、このcommitは今どこにあると思いますか？
当て嵌まるものすべてにチェックしてください。git pushを実行する前と実行した後でも一つのcommitが
一つのリポジトリにあることは可能であるということを忘れないでね。

あなたがgit pushを実行する前は、あなたの変更はgit logによるとローカルにだけありました。
commitは自動的にはリモートと共有されません。つまり、もしあなたが、変更を共有したければ、あなたは手動であなたのbranchをpushする必要があります。

あなたがgit pushを実行した後は、あなたの変更はローカルとあなたのforkに存在していました。
それはあなたがフォークしたリポジトリであるLarryのリポジトリには存在しませんでした。
あなたが最初にforkした理由は、あなたがLarryのリポジトリを変更する権限を持っていなかったからです！

Reflect:Fork,CloneとBranch
さて、あなたは、GitHub上のリポジトリのコピーをforkによって作成するやり方を見ました。
以下の質問に進んで、あなたの考えをreflectionファイルに追加しましょう。

fork,clone,branchの違いを説明しなさい。
いつ、あなたは他の代わりにそれを使いますか？

forkはGitHub上限定のcloneである。GitHub上にあるリポジトリを自分のGitHubアカウント直下にコピー＝クローンする。これは、もとのリポジトリを編集する権限がない場合に自分のアカウント直下にforkすることによって編集可能になるからである。

cloneは任意の2つのリポジトリ間で行われる。リポジトリをそっくりコピーする。

branchは単一のコンピューター上でのみ発生する。

また、変更をコミットしてからプッシュすることができます。終了したら、「次へ」をクリックします。








