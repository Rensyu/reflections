あなたはもうバージョンコントロールと使いたい時、自分のPCでバージョンレポジトリを作成して改変するGitの使い方を知っています。
あなたはbranchを作成して新機能をトラックするやり方と、あなたの変更を一緒にマージするやり方を学びました。
このレッスンでは、あなたは他の人と変更を共有する仕方と他の人の変更を自分のプロジェクトに持ってくる方法を学びます。
これをやる方法は沢山ありますが、私達はそれらのゴールを達成するために、特別にデザインされた製品であるGitHubに焦点を当てます。
GitHubはgit repository全体を他の人々と共有するのを簡単にしてくれるウェブサイトです。
例えば、ここに私達がUdacityで作成したrepositoryがあります。
このrepositoryはブラウザベースのあなたの冒険物語を作成するソースです。
ここにrepositoryの全ファイルがあります。クリックしてみると、ディレクトリ構造をナビゲートします。
そして私はcommitの履歴を見ることが出来ます。
メインページに戻ってスクロールで少し下に下がってみると、あなたはそのプロジェクトについての情報を見ることが出来ます。
私はまたファイルがコードや物語のようなプレーンテキストだと想定すると直接ファイルの内容を眺めることができます。
GitHubはまた、画像や3Dモデルや地図データのような幾つか他のフォーマットもサポートしています。
このファイルでは、私は物語自体を通してクリック出来て、いくつかの選択を始めることが出来ます。
あなたはここをクリックしていつでもrepositoryのメインページに戻れます。
これはpublic repositoryなので、誰でもこれらの内容を見ることが出来て、変更を提案出来ます。
Carolineと私はこのレッスンでこれがどのように動作するのか詳細に練習するつもりです。
そしてレッスンの終わりまでに、あなたはそれを自分自身に寄与することが出来るでしょう。
これは生きているプロジェクトですので、このページを訪れるまで、物事は少し違って見えますが、
基本は同じです。GitHubはこのプロジェクトのように多くの公共プロジェクトのホームです。
沢山の公共プロジェクトがオーブンソースで、あなたは自分の目的のためにコピーとコードの改変が出来ます。
GitHubはまた、あなたに変更の提案と、変更をプロジェクトの作者に送り返させることが出来ます。
これらのオーブンソースプロジェクトは10人の寄与者しかいないmathquillのような非常に小規模で比較的知られていないものです。あなたはこれを知っているかもしれませね。
いくつかのプロジェクトはPythonのデフォルトで使うインタラクティブシェルよりもずっと便利であるiPythonのようにずっと大規模です。
もう一個の大規模プロジェクトはweb開発を簡単にするframeworkであるBootstrapです。
またHTMLと相互作用するのを簡単にするJavaスクリプトのライブラリであるjQueryもあります。
またAtomもあります。コードを編集するようにデザインされたテキストエディタでユーザーがユーザーエクスペリエンスをカスタマイズすることが出来ます。
これらのプロジェクトは誰でも理論上は貢献できます。もちろん、どんな変更でもプロジェクトを維持管理している人々に受け入れられねばなりません。
しかし、オリジナルの作者があなたの変更を取り込まないことを選択したとしても、あなたは依然として自分自身のバージョンを維持することが出来ます。
GitHubは誰もが公共repositoryを無料でホストして、プライベートrepositoryは有料でホスト出来るようにして、オープンソースを促進することを目指している。　
Udacityを含む多くの企業が彼らのプロプライエタリコードの変更をトラックするのにGitを使用していて、彼らのrepositoryのプライベートコピーをホストするのにGitHubを使用しています。そして開発者が変更を投稿したときに、コードの批評を簡単にしています。
このレッスンのために、あなたはGitHubと沢山交流します。作成、変更、パブリックリポジトリへの変更の提案。
それであなたはアカウントを設定する必要があります。これはとても簡単ですが、あなたは多分、スムースにもう少し複雑なコマンドラインからGitHubと交流するために設定したいでしょう。
あなたはこのビデオのあとで全ての設定の指導を見ます。
さて、あなたはGitHubアカウントの設定を完了して、あなたの最初のパブリックリポジトリを作成する時間です。
すなわち、あなたのreflectionリポジトリをGitHubに置きます。
多くのクラウド型ホストシステムのように、これは、あなたのPCのリポジトリとGitHubでホストされているバージョンの間で同期を伴います。それはあなたがwebサイトで見るバージョンです。
GitHubと交流する時に、あなたが送受信する情報はgit commitの型式なので変更は送信される前にstageに登録されてcommitされます。
私がGitHubリポジトリに作業ディレクトリやstaging areaを描かなかったことにあなたは気付いたかもしれません。
これらは、全てのリポジトリに存在しますが、GitHubリポジトリはGitHubのサーバーにホストされているので、
直接アクセスすることが出来ません。なので、ここでは本当に関係がありません。
あなたのファイルのクラウドホストバージョンと同期する多くのサービスと違って、GitHubを使うときは、
あなたはいつ、どのように2つのバージョンを同期するのか選択する必要があるでしょう。
あなたはこれを、gitがあなたにいつcommitをセーブするのか手動で決定させたのと同様に考える事ができます。
もしGitHubが毎回commitの後で自動的にあなたのローカルバージョンを更新したら、完璧に準備が出来る前に物事を公にすることになります。新機能はよく複数のcommitを要求するので。
それでは、同期は自動で起きないので、私達はどうやってリポジトリのローカルコピーとGitHubでホストされているバージョンを同期しますか？
特に、あなたはどうやって、既存のリポジトリの現況をこれから始めるGitHubに反映することが出来ますか？
あなたはGitCloneと答えたいかもしれません。それは、レッスン1に戻ってGitHubからリポジトリのコピーをローカルに取得するやり方です。
これはかなり合理的な推測ですが、GitHubは直接彼らのサーバーにクローンすることを許可しないことが判明します。
なので、代わりに、まず最初にGitHubに空のリポジトリを作成する必要があります。
今は実際にこれをやらないので心配しないで。重要な部分は、今のところは既存の場所の空のリポジトリと考えることです。
２つのリポジトリの間でデータを同期させるには、gitはリモートリポジトリという概念を持っています。
これは、あなたにあなたがcommitを送受信したいリポジトリの場所を保存させます。
Gitユーザーは良くこのリモートリポジトリのことを単にリモートと呼びます。
あなたはCarolineともうすぐリモートのセットアップの仕方を見ます。でも今のところは、私は2つのリポジトリの間の接続を矢印で説明します。
それでは、どんな種類の交信がリモートと出来ますか？そうですね、あなたはデータをプッシュしたりデータをプルしたり出来ます。私は前にあなたがリモートから送受信するものはcommitだと言いました。
しかし、個々のcommitを選択する代わりに、データを送受信する最も一般的な方法はbranchを特定することによってです。
それで、このリポジトリの場合、そして多分あなたのreflectionリポジトリも同様ですが、私達は
master branchをプッシュしさえすれば良いです。masterの先端のcommitによって全て到達可能なので、あらゆるcommitが送信されます。
それで、あなたがmasterをpushすると、これらのcommitの両方が現れます。
もし、これらのcommitのどちらか一方が、私達がpushコマンドを実行する前に、既にGitHubのサーバーにあれば、
gitはわざわざそれを送信しないでしょう。
もし、あなたが何百、何千ものcommitがある大規模なリポジトリを持っているところを想像して、
毎回、個々のcommitを送信するのは非常に非効率的でしょう。
ちょっとこの概念が理に適っているのか確認してみましょう。
仮説の状況を見てみましょう。もし私がローカルにこのcommit履歴を持っていて、このGitHubはリモートとして設定して再投稿したら、次にbranch aをpushします。どのcommitが送信される必要がありますか？
リポジトリ間のコミュニケーションはcommit履歴のレベルだけで起こるので。ここでは私は両方のリポジトリをcommit履歴を示すだけで描いているということに留意して下さい。
なので、ワーキングディレクトリやstaging areaのどちらもここでは必要ありません。

branch aをプッシュすると、Gitは先端のe53から開始して、遡ってそのcommitから到達可能な全commitを探して、
GitHub履歴にまだ存在しないcommitを送信します。
なので、e53とfd2は両方共送信されます。しかしbranch aから到達不可能なので6b4は送信されません。
それからa3bも送信されません。なぜならば、a3bは既にリモートリポジトリに存在しているからです。
そして、pushした後で、GitHubリポジトリはこのように見えます。

Sarahが言っていたように、私のreflectionリポジトリをGitHubで共有するために、私はまず最初にGitHubにリポジトリを作成します。
これをするには、私は確認します。ログインしているか　このコーナーの私のユーザー名を探して、次に任意の画面上で、
私はプラス記号をクリックしてnew repositoryを選択します。
私はそのリポジトリをreflectionsと名付けて、publicのままにしておきます。
さて、私はそのリポジトリをREADMEで初期化したくありません。もし私が何かコンテントを作成する前にGutHubでリポジトリを作るのなら、私は多分このboxにチェックします。
何故ならば、その方法だと、私のリポジトリは一個のcommitがある状態で開始するからです。
あなたは、commitが無いリポジトリをクローン出来ません。だからこれは時には良いアイディアです。
しかし、私は既に自分のリポジトリに共有したいcommitsを持っています。
このボックスにチェックはしません。
次に、私はリモートとしてこのリポジトリに私のPC上のreflectionリポジトリを追加します。
丁度、私がbranchを見たり作成するのにコマンドgit branchを使うことが出来るように、
git remoteはリモートを見たり作成したり出来ます。
最初に私は現在のリモートのあらゆるものを見るためにgit remoteコマンドを引数無しで実行します。
出力は空です。何故なら、私はまだリモートに何も追加していないからです。
次に、リモートとしてGitHubのリポジトリを追加するために、私はgit remote addを実行して、
私は私が使用したい名前を与えます。
さて、私はここでどんな名前でも使えます。それはGitHubのリポジトリを呼ぶために私がこのリポジトリ内で使う名前です。
もしあなたが一個のリモートを持っているだけならば、それをoriginと名付けるのが普通ですので、私もそうします。
次に私は自分のリモートのURLを与える必要があります。私はそのURLを今reflectionリポジトリを作成したGitHubのページで見つけることができます。
それで、私はそのURLをコピーして、私のコマンドの中へペーストします。そしてEnterを押します。
さて、git remoteをもう一度実行してみると、私はoriginリモードが作成されたのが見えます。
そのURLが正確に追加されたことを確認するために、私はgit remote -vを実行します。
Vはverboseを表していて、gitリモートがより多くの情報を出力することを意味しています。
即ち、それはより言葉数が多く、冗長で詳細になります。
その出力は私がデータをfetchしてくるところと、私がデータをpushするところの両方のURLを表示しています。
殆どの場合、これらは同じURLです。
ここに、私が今ペーストしたのと同じURLが見えます。
さて、私の変更をリモートに送信するために、私はgit pushコマンドを使います。
git pushは2つの引数を取ります。変更を送信したいリモートと、私がpushしたいローカルのbranch名です。
私はリモートをoriginと名付けました。そして私は全変更をローカルのmaster branchで行いました。
だから、
git push origin master
を実行します。
私がgit pushを実行する前に、私は自分のローカルリポジトリのmaster branchで山程の変更をしました。
そして、私のGitHubのリポジトリは空です。git pushを実行すると私のmaster branchから到達可能なcommitの全てをoriginにコピーします。それは私のGitHubのリポジトリです。
デフォルトでは、GitHubに作成されたbranchは私がpushしたローカルのbranchと同じ名前を持ちます。
なので、このbranchもまたmasterと呼ばれます。
さて、私はGitHubのページを更新してみます。そして、私は私の全ファイルが追加されたのが見えます。
私はまた、私がいるbranchがmasterを名付けられたことがここにも見えます。
さて、あなた自身のGitHubアカウントでreflection repositoryを作成してみましょう。
そしてあなた自身のPCからあなたのreflectionsをGitHubにpushしてみましょう。
あなたの新しいreflectionsリポジトリのリンクをフォーラムに投稿しましょう。
次に、ちょっと他の生徒のreflectionsを何人分か読んでみましょう。
あなたはまだ彼らのレッスン3のreflectionsは読みたくないかもしれませんが。
他の人々が言った事を読む前に、もしあなたが彼らについて自分自身として考えると、彼らのreflectionはもっと価値があるでしょう。
一旦あなたのreflectionsリポジトリへのリンクを共有したら、このボックスをチェックしましょう。

SSHのではなくHTTPSのURLをコピー！
1:29でCarolineはリポジトリへのURLをコピーしました。ビデオは間違ってリポジトリがSSHでアクセスされるのに使うURLを表示しています。このコースは生徒はSSHではなくHTTPを使用することを想定しています。HTTPSボタンをクリックして現れたHTTPSのURLをコピーして下さい。それはgit@github.comではなくて、https://で始まります。
もしあなたが、代わりにSSHを使うことに興味があれば、あなたはここの指導に従えます。
https://help.github.com/articles/generating-ssh-keys/
しかし、あなたが既にSSH keyに慣れていない限りお薦めしません。

あなたのreflectionsを共有しよう。
私達はあなたが大胆にあなたのreflectionをGitHubで共有することをお薦めします。もしあなたが、自分の解答のどれにも満足していなかったら、一番良い解決方法はその解答を1個か2個のcommitで更新することです。
前の解答はまだcommit履歴で見ることが出来ますが、時間をかけてあなたの視点を更新することが、学習プロセスの一部です！
あなたの視点の更新を表示するcommit履歴を持つことは、あなたに少しではなく十分に反映されます。

それはつまり、もしあなたが、自分のreflectionリポジトリに共有したくない何かを書いたら、あなたは、あなたがその変更を導入する前にそのcommitをcheckoutすることが出来て、その時点で新しいbranchを作成して、あなたが喜んで共有したいその他の変更を何でも新しいbranchにcommit出来ます。
そして、新しいbranchだけpushすることによって、あなたは自分のoriginal branchをプライベートに保てます。

願わくば、あなたがこのコースの他の生徒によって投稿されたreflectionsを見て楽しんだことを。
彼らのreflectionはあなたのreflectionとどのように違っていましたか？

さて、あなたはGitHubにリポジトリを作成しました。そして、その中にcommitが幾つかあります。
GitHubのウェブサイトで、これがどんなふうに見えるか見てみましょう。
Creage Your Own Adventureリポジトリのように、私はどんなファイルがそのリポジトリにあるのか見えます。
またスクロールで上に戻って、私はcommitsをクリックするとcommit履歴が見えます。
これは、コマンドラインでgit logを実行するのと同様です。
しかし、それはローカルのリポジトリの履歴を表示するのではなく、GitHub上のリポジトリの履歴を表示します。
なので、あなたはGitHubにpushした変更だけが見えます。また、GitHubのWebサイトでプレーンテキストファイルの直接編集と作成が可能です。
たった今、私は自分のローカルリポジトリからGitHubにpushしました。なので、両方とも同じコンテントを持っています。
しかし、私が幾つかコンテントを直接GitHubに追加しようとすると、あなたのローカルのリポジトリには現れていない変更がGitHubで現れた時、何が起きるかあなたは見れます。
実際に、もしあなたがGitHubで直接変更すると、これは起こり得ます。しかしまた、もしあなたが、他のコンピューターからGitHubに変更をpushしても起こり得ます。
或いは、もしあなたのプロジェクトで作業していてGitHubに変更をpushする他の人が人がいても起こり得るのです。
新規ファイルを作成するには、このプラス記号をクリックします。私は自分のレッスン3reflectionのファイルを作成するつもりです。そして私が最初のreflectionプロンプトになるでしょう。あなたはこのプロンプトをすぐに見ることになります。さて、スクロールで下がって、ここに、私はcommitメッセージを入力出来ます。
メッセージは最初のboxに入ります。そしてもし私が自分のcommitのもっと長い説明を追加したければ、私は二番目のboxを使うことができます。でも私はそこは空白のままにしておきます。
さて、画面の右側のCommit new fileがクリックできます。さて私は新規commitが作成されたことが見えます。
レッスン3のためのファイルを作成して最初のreflectionを追加しなさい。
さて私は直ぐにこれらの変更を自分のローカルリポジトリにpullするのをデモします。
なのであなたは付いてこれます。
あなたは次の画面でそれのやり方について幾つかの指導を見ます。

GitHubで変更する
今、あなたはリモートリポジトリの作り方と、そこに変更をpushするやり方を見てきたので、GitHubのウェブサイトを使用して、あなたのレッスン3のreflectionを新規作成して以下の質問とあなたの考えをそのファイルに追加してみましょう。

もし、あなたがダウンロード可能セクションのファイルlesson_3_reflection_prompts.txtから始めるのが好きならば、そのファイルがダウンロード出来ますし、それをローカルでcommitしてGitHubにpushしてあなたの反応をGitHubのウェブサイトを使用して、そのファイルに追加出来ます。

Reflect:リモートリポジトリの使用
以下のreflectionプロンプトを使いなさい。

あなたのローカルでの全作業を保持するよりもむしろ、リモートリポジトリを使いたいのはいつですか？

あなたの変更のcommitが終わったら、Nextをクリックしてそれらの変更を自分のコンピューターにpullするやり方を
見てみましょう。

変更をPullする。

Carolineのリポジトリの２つの異なったバージョン(ローカルとGitHub)がこの時点でどんなふうに見えるかについて
考えてみましょう。
これがCarolineがGitHubと交流する前のローカルバージョンの様子です。
次に彼女はmaster branchをpushしました。そして次に、そのcommitsはmaster branchにあったので、
全て送信されました。なので、この時点で、両方のリポジトリとも同じ履歴を持っています。
次にCarolineがGitHubで直接ファイルを編集して、master branchにコミットしてmasterを更新しました。
なので、これが今我々がいるところです。
彼女のローカルバージョンはリモートのGitHubバージョンから遅れています。
リポジトリを再び同期するには、彼女は自分のmasterをローカルバージョンにpullする必要があります。
これで、新しいcommitがローカルバージョンにもたらされて、masterが更新されます。
さて、私はCarolineに引き渡して、これをコマンドラインで見てみましょう。

Sarahありがとう。さてご覧のように、私が丁度作成したcommitがGitHubのサイトのcommit履歴に表示されています。
しかしながら、私がgit logを実行すると、そのcommitは私のローカルリポジトリには現れていないのが見えます。
ローカルリポジトリに現れるようにするために、私はgit pullを実行します。
私がgit pushを実行した時のように、私はリモートを特定する必要があります。それに私はoriginを名付けました。
Pullするためには、私はまた自分がpullしたいbranchを特定する必要があります。
そのbranchはリモート上のmaster branchです。
git pull origin master

私がgit pullを実行する前に、私はGitHubにpushした幾つかのcommitが自分のローカルリポジトリにありました。
私はまたレッスン3のreflectionファイルを追加して新しいcommitをGitHub上に持っています。
私がoriginリポジトリからmaster branchをpullした時、即ち、GitHubの自分のリポジトリ、それは
GitHubのmaster branchから全部の到達可能なcommitを自分のローカルリポジトリにpull downします。
この場合、私はmaster branchにチェックアウトしていたので、gitはまた私のローカルのmaster branchのラベルをその新しいcommitを指すように更新しました。
さて、これらの2つの名前が同じである必要はありませんが、普通は同じ名前です。
そして、私は再びgit logを実行します。すると、私は今、自分の新しいcommitがローカルリポジトリに現れたのが見えます。
さて、進んで、あなたがGitHubで行った変更をあなたのローカルリポジトリにpullしましょう。
終わったら、次のうち、どれが本当ですか？
.あなたのローカルリポジトリの幾つかの変更はGitHubに存在しない

GitHubにない変更は、あなたのローカルリポジトリにも何の変更もないべきです。
なぜなら、最も最近の変更をローカルリポジトリに加えた後で、あなたはgit pushを実行したので。(だから上は嘘)

.GitHubでの変更の幾つかはあなたのローカルリポジトリに存在しない

同様にあなたはgit pullを最も最近の変更をGitHubで直接加えた後で実行しましたね。(だから上は嘘)
なので、あなたのローカルリポジトリに無いどんな変更もGitHubにあるべきではありません。

.どちらも本当ではない。あなたのローカルリポジトリでの全変更はGitHubにあるし、その逆もある。(true)

代わりに、2つのリポジトリは現在、同じcommitを持っているべきです。(なので、上は本当。)

コンセプトマップ:GitHub,Pull,Remote

前回コンセプトマップを再訪してから、私達は幾つか新しい概念を導入しました。
・GitHub
・git push
・git pull
・remote

私達の新しい概念はどこに入るでしょう？

残された画面の余白は余り無かったので、私達は前のレッスンからこのレッスンで取り上げられて新しい概念のためのノードに追加される新しい概念としっかり絡まっていない幾つかの概念を削りました。

どの概念がどこに属しますか？
以下のクイズに従って、あなたがそれぞれ空のノードに属するを思う概念を書き込んで下さい。
このマップが主観的であることを忘れないで下さい。私達がここに示したマップはあなたの精神的なモデルに正確には適合しないかもしれません。即ち、あなたが概念の間にみえる接続を気楽に描き出して下さい。
そして、あなたのバージョンをフォーラムで共有しましょう。

OK.これらがどこに適合するのか見てみましょう。GitHubから始めます。GitHubはユーザーにGitと交信させるサービスです。私達がこれを表すには幾つか違った方法があります。GitHubがGit上で動作しているかもしれないし、
GitHubがGitを参照しているのかもしれない。
でも私はそれを、GitはGitHubの一部であると表現することを選びました。
さてリモートについて考えましょう。あなたのローカルリポジトリのリモートは基本的に、他のリポジトリへの参照です。
なので私達はリモートはリポジトリを参照している言えるでしょう。また、あなたがリポジトリをクローンする時は、
リモートがあなた用に自動的に設定されます。なので私達はcloneはリモート上で動作すると言えるでしょう。
なので、remoteはここに入ります。
この時点で、残りの2箇所が全く同じ状態であります。両方共リモート上とbranch上で動作します。
なので、私達はこれらを、どちらの場所でも入れられます。
これが本当に合っているか確かめてみましょう。あなたがpushかpullする時は、あなたはどのbranchをあなたがpushやpullしたいのか特定しなければなりません。なので、それは間違いなくbranch上で動作します。
pullはリモートからbranchを取って、ローカルリポジトリに持ってきます。
そしてPushは正反対に、branchを取ってリモートに持って行きます。
なので、これらは両方共同様にリモートで動作しますね。さあ、私達は現時点でのコンセプトマップが出来ました。

Reflect:マニュアル v.s. 自動Pull

さて、あなたは変更をGitHubにpushしてGitHubから変更をpullしました。以下の質問とそれに対するあなたの考えを
reflectionファイルに追加しなさい。

なぜ、Gitに自動であなたのリモートリポジトリと一緒に最新に保たせるよりも、あなたは常に変更を手動でpullしたいのですか？

何でだろう？

あなたは、また、自分の変更をcommitしてpushしたいかもしれません。Nextをクリックして、 もしあなたがリポジトリへの変更を共有したくて、あなたがオリジナルのファイルを変更する権限がなかったら、あなたはどうするのかSarahが調べます。

私達の同僚のLarry,あなたが最初のレッスンで見ました、はレシピのリポジトリをまとめています。
Carolynと私はこのレシピが好きですが、私達はそのレシピをもう少しより私達の味付けに微調整したいです。
そうして私達が友人とレシピを共有できるように。
Larryは私達が変更バージョンを共有することにOKです。しかし、彼は自分のバージョンをそのままにしておきたいのです。
Carolynと私は二人共変更がしたくて、そのレシピを他の人々に見て欲しいし、自分たちのバージョンをGitHubでホストするのは最適です。
私達が話してきたことをするだけで、GitHubでコピーを取得するのは可能でしょう。
まず第一に、私達はLarryのリポジトリを指定して、それを例えばCarolineのコンピューターにクローンします。
これで、自動的にLarryのリポジトリがOriginと呼ばれるリモートとして設定されます。
次に、私達は新しいリポジトリをCarolineのアカウントでGitHubに作成することが出来ます。
そして彼女はこの新しいリポジトリをリモートとして設定出来ます。それは彼女が好きなように呼ぶことが出来ますが、
例えばOur versionにしましょう。
次に私達が前に見てきたように、彼女は変更をリモートにpush出来ます。
そして次に、私はこのリポジトリに同様に貢献したいので、私はそれを自分のコンピューターにクローンして
Carolineのバージョンをoriginとして設定することができます。
これは、かなり複雑ですが、そして、それはまたLarryに彼がオリジナルのリポジトリに行った仕事に何の感謝も与えていません。
誰かが我々のバージョンを見て、Larryのバージョンについて私達が明確にリンクを張らない限り何かアイディアを持つ手段が何もないので。
私達のパートにより少ない労力で同様の効果を上げるには、GitHubにはForkingと呼ばれる機能があります。
これはあなたに最初にそのコードをあなたのローカルマシンにpullさせることなしで、誰か他の人のリポジトリをGitHubに直接コピーさせます。
あなたはクリック1回で、既存のリポジトリをforkして、それをあなたのアカウントの直下に出現させることが出来ます。
次に、あなたの変更を加えるには、ファイルがGitHubで直接編集出来るほど単純でない限り、あなたはコードを自分のコンピューターにpull downしたいかもしれません。ForkはCloneにとても似ています。実際、ForkはGitHubがあなたのために自分のコンピューター上で作成する単なるcloneです。
Forkには幾つか他の副作用があります。GitHubがあなたのリポジトリをforkした人の数をトラックし続けるように。
そしてforkは全てオリジナルにリンクを張ります。それはまたオリジナルのリポジトリに変更を提案して戻しやすくします。
それは私たちはレッスンの後のほうで詳細をカバーします。
それで、Larryのバージョンは既にGitHubにあるので、forkするのはこの場合は非常に理に適っています。
Carolineは彼女のアカウントでfork出来ます。そして私達は各自、私達のバージョンをクローン出来ます。
クローンはオリジナルのリポジトリのことについて、何も知る必要はありません。
あなたのコードのバージョンのための多種多様な方法の間に、関連した概念が沢山あるので、私達は今までのことを全部理解していることを確認したいです。
以下の各ダイアグラムはそれぞれ、branch作成、forkかcloneを表しています。
テキストボックスを使用して、各ダイアグラムによってどの概念が表されているか示しなさい。
Branchは単一のリポジトリで発生します。もちろん、あなたはbranchのpushとpullが出来ますが、
branchを作成する時は、branchを1個の単一なリポジトリに作成することになるので、唯一、その性質に該当するのはこれです。
私達は一本のbranchと、ここに2本目のbranchがあります。なので、これがbranchです。
Cloneは既存のリポジトリを指定して、そのままそっくりもう一個のリポジトリを作成することを含んでいます。
オリジナルのリポジトリは、この場合のように、リモートになりうるので、ここに、私達はGitHubからローカルマシンにcloneしました。
或いは、あなたはローカルリポジトリでさえあなたのコンピューター上の別の場所にcloneすることが出来ます。
私達はこれについてはまだ本当に話していませんので、これは多分少し扱いにくかったでしょう。
これもクローンに大変似ていますが、私達が私達のリポジトリをGitHubからGitHubにクローンしたことを
思い出して下さい。あなたは、それをGitHubに組み込まれたfork機能を使用して出来ます。
クローンが任意の2つのリポジトリで動作するのに対して、ForkはGitHubの文脈内でのみ使用され、既存のGitHubリポジトリを指定して、そのコピーを作成します。

レシピリポジトリをForkするには、最初に私はGitHubでLarryのリポジトリを訪問します。
あなたは、このリポジトリのリンクをインストラクターのノートで見つけることができます。
さて、私はそのページのこの部分にズームして、ここのForkボタンをクリックします。
すると、私のGitHubプロファイルにそのリポジトリのコピーが作成されました。
さて、私が自分のプロファイルを訪問すると、レシピのリポジトリがここに見えます。
今度は、私はこれらのレシピをGitHubのウェブサイトでやるよりも自分のコンピューターで編集出来るようにしたいです。
それで私はまたこのforkをクローンしたいです。レシピは私がどこで編集しようが構いませんが、
もし私がコードを書くとしたら、私は間違いなく自分のコンピューターで編集出来るようにしたいです。
GitHubのページは私がクローンすべきURLをここに載せているので、私はそのURLをコピーします。
そして私のgit cloneコマンドの中にペーストします。さて、私は新しいリポジトリにcdで移動して、
あなたは私がそこにpush出来るようにGitHubのforkをリモートとして追加する必要がある思うかもしれません。
しかし、実際にはあなたがリポジトリをクローンする時には、Gitが自動的にあなたがクローンしてきたリポジトリを
指すリモートを設定します。
私はそれをgit remote -vを実行して確認します。
そして、思った通り、originと呼ばれるリモートがありました。そして、そのURLは私のGitHubのリポジトリを指しています。
最後に、私はSarahが私と共同作業出来るようにしたいので、彼女はこのリポジトリにpushするパーミッションが必要になります。
私は設定から、Collaboratorをクリックして彼女をコラボレーターとして追加します。そして次に彼女のGitHubユーザー名のsalogel42を追加します。あなたはSarahをあなたのリポジトリに共同作業者に追加する必要はありません。
しかし、あなたはあなたのリポジトリにpush出来るようにしたい人を誰でも追加出来ます。
そして、私はAdd collaboratorボタンをクリックします。

さて、LarryのリポジトリをあなたのGitHubプロファイルにforkしましょう。
私はこのレッスンを通じて自分のforkを変更するので私のプロファイルのレシピリポジトリをforkしないでくださいね。
そして、あなたはこれらの変更はしたくないです。
もう一度、あなたはLarryのリポジトリの完全なリンクをインストラクターノートで見つけることができます。
forkを作成したら、あなたのforkをクローンして、git remote -vを実行して、その出力をこのボックスにペーストしてください。

私がgit remote -vを実行すると、私は両方のURLが私のGitHubのforkのURLであるgithub.com/cbuckey-uda/recipes.gitになっているのが見えます。
あなたも自分のforkのURLが見えるはずです。それであなたのユーザー名がここの私のユーザー名の代わりにあります。

新しいレシピを追加しましょう。
あなたのコンピューターであなたの好きなレシピを追加して、master branchにcommitしましょう。

あなたの変更をPushしましょう。
master branchをあなたのforkにPushしましょう。pushのやり方を思い出せないならば、このビデオを見なおして下さい。終わったら、続けて次の画面で異なった時点でどこにあなたのcommitが存在しているのか質問に答えてください。

あなたのcommitはどこにありましたか？
あなたが、git pushを実行する前、あなたが新しいレシピを追加したcommitはどこにあったと思いますか？
同様に、今、あなたはgit pushを実行しましたが、このcommitは今どこにあると思いますか？
当て嵌まるものすべてにチェックしてください。git pushを実行する前と実行した後でも一つのcommitが
一つのリポジトリにあることは可能であるということを忘れないでね。

あなたがgit pushを実行する前は、あなたの変更はgit logによるとローカルにだけありました。
commitは自動的にはリモートと共有されません。つまり、もしあなたが、変更を共有したければ、あなたは手動であなたのbranchをpushする必要があります。

あなたがgit pushを実行した後は、あなたの変更はローカルとあなたのforkに存在していました。
それはあなたがフォークしたリポジトリであるLarryのリポジトリには存在しませんでした。
あなたが最初にforkした理由は、あなたがLarryのリポジトリを変更する権限を持っていなかったからです！

Reflect:Fork,CloneとBranch
さて、あなたは、GitHub上のリポジトリのコピーをforkによって作成するやり方を見ました。
以下の質問に進んで、あなたの考えをreflectionファイルに追加しましょう。

fork,clone,branchの違いを説明しなさい。
いつ、あなたは他の代わりにそれを使いますか？

forkはGitHub上限定のcloneである。GitHub上にあるリポジトリを自分のGitHubアカウント直下にコピー＝クローンする。これは、もとのリポジトリを編集する権限がない場合に自分のアカウント直下にforkすることによって編集可能になるからである。

cloneは任意の2つのリポジトリ間で行われる。リポジトリをそっくりコピーする。

branchは単一のコンピューター上でのみ発生する。

また、変更をコミットしてからプッシュすることができます。終了したら、「次へ」をクリックします。


このレッスンの今までは、2つのリポジトリが同期しなかった時、一つのリポジトリに、もう一方のリポジトリにはないcommitがありました。この場合のように。
両方の両方のリポジトリに同じbranchから到達可能な新規commitがあったらどうしますか？
この場合に、もしあなたがpullかpushをしたら何が起きると思いますか？
以前のレッスンでpullした時は、あなたのリポジトリには、リモートにはないcommitが一つもなかったので、
pullはあなたの状態をリモートと全く同じに設定してくれました。
しかし、この場合にもしそれが起きると、私達はこのcommitを失うでしょう。
それでは、実際にbranchをpullしたら何が起こるでしょう？
あなたが望むのはこれらのbranch両方の結合バージョンです。これに聞き覚えがありますか？
あなたが本当にしたいのは、branchのローカルとリモートのバージョンのmergeです。
織り交ぜるために、あなたが実際に両方のリポジトリに変更を加えてみたら、私達はどのようにそれが動作するか詳細を調べます。
個人的なプロジェクトでは、これは実際には、あなたが複数の異なるコンピューターから作業するか、一部はGitHub上で直接編集して他はローカルで編集した場合にのみ起きます。
このような問題が生じるもっと一般的な理由は、あなたが他の人と共同作業する時です。
Carolineと私はコラボレーションをデモしますが、不幸にも、私達は皆さん一人ひとりとコラボレーションする時間がありません。
あなたは、コラボレーションのCaroline側に従って下さい。
そして、私が変更したら、あなたは、私が同じ変更をあなたのリポジトリに行ったように見えるようにする私達が書いたコードを実行します。　
その時になったら、これのやり方は私達が指導します。
まず最初に、あなたはちょっとした変更を、あなたのローカルのレシピの一つに加えます。
このビデオのあとで、あなたはそうする指導を見ます。

チリのレシピを変更しましょう。
変更を衝突させるために、二名の人によって行われた変更が欲しいでしょう。即ち、あなたとSarahです。
まず最初に、あなたはローカルで変更します。あなたの好きな新しいスパイスを材料リストに加えて
チリのレシピを改変しましょう。そして手順のstep2をそのスパイスの説明に改変しましょう。
あなたの変更をcommitしますが、まだあなたのforkにはpushしないで下さい。
今あなたがpushするとこの後の演習が正常に動作しなくなります。

終わったらこのボックスにチェックしてください。

私はレシピにオニオンパウダーを加える事に決めましたので、私は材料リストにオニオンパウダーを追加して
次にそれを、下のほうのここにも追加する必要がありますね。
それに、この行は今すこし長いので、私は2行に分割tます。
さて、私はgit diffを私が今行った変更のダブルチェックに使います。そして私はオニオンパウダーの追加が見えます。
チリのレシピをstaging areaに追加して、commitします。
さて、私がgit statusを実行すると、私のbranchが
"Your branch is ahead of 'origin/master' by 1 commit."
あなたのbranchは'origin/master'より1commit先行してます。
と見えます。そして、そのcommitが私が今作成したものです。

OK,今私はレシピにオニオンパウダーを追加しました。oh,Sarahからメッセージです。
私は彼女がチリのレシピからクミンを取り除く変更をしたのだと思います。
そうですね、私は賛成です。私はクミンが大嫌いです。いいですね！
さて、私はそれを見てみます。私はSarahの変更を見るためにcommit履歴を見てみます。
これのようですね。さて、私はスクロールで下がってdiffを見ます。
かなり単刀直入ですね。彼女はクミンを材料リストから削除して、彼女はクミンを加える手順を削除しました。
Sarahと私は同じ行を変更したので、Gitはこれを衝突としてマークするでしょう。
次の画面で、あなたはSarahの変更をあなたのforkに追加する指示をみます。
そして、Sarahはどうやって私がこの衝突を解決するのか調べます。

Sarahの変更をシミュレート

Downloadableセクションにsarah_changes.shと呼ばれるファイルがあります。それはSarahがGitHubであなたのforkを変更したように見せるコードを含んでいます。コードを実行するために、ファイルをダウンロードして、Git Bashかあなたのターミナルを使用して、そのファイルをセーブしたディレクトリにcdします。次に、bash sarah_changes.shとタイプして続いてスペース一個、続いてあなたのforkへのURL。例えば、もしCarolineがこのコードを実行するなら、
 bash sarah_changes.sh https://github.com/cbuckey-uda/recipes.git
でも、あなたは、Carolineのforkのではなく自分のfork用のURLを使うべきです。
もし、あなたがパスワードキャッシングの設定をしていなければ、GitHubのユーザー名とパスワードの入力を促されるでしょう。

あなたが、Sarahがあなたのforkを変更したようにみせるコードを実行したら、レシピのリポジトリでgit logを実行して、それからGitHubでforkのcommit履歴を見て下さい。各commitについて、あなたのローカルリポジトリかあなたのforkに現れているかどうかチェックしなさい。(注意：幾つかのcommitは両方の場所に存在しているかもしれません)

どのcommitがどこにあるか？
Larryがチリのレシピを追加したcommitは、あなたがforkする前にオリジナルのリポジトリに存在したので。両方の場所にあるべきです。あなたが新しいスパイスを追加したcommitは、ローカルでcommitしたけれども、pushはしていないので、ローカルにだけあるべきです。Sarahがクミンを削除したcommitはSarahが変更してそれをGitHubにpushしたけれども、あなたはまだpullしていなかったので、GitHubにだけあるべきです。

リモートの変更をmerge
OK,私が先程言いました。全部を最新にするのは、ローカルとリモートのbranchのmergeを要求します。
実際、これはどのように動作するのでしょうか？今にしてみると結局のところ、あなたがリモートを設定した時、
Gitはすべてのリモートbranchのローカルコピーを保存したのでした。
これらは、あなたが最後にbranchをpush、或いはpullした時のリモートbranchの状態を含んでいます。
これが、リポジトリの生涯でどのように展開するのか見てみましょう。
私達はGitHubにreadmeと一緒に作成されたリポジトリと、それがクローンされたリポジトリを考えます。
クローンはoriginと呼ばれるリモートをあなたのために設定することを思い出して下さい。
私達は既にあなたがリポジトリをクローンした時に、あなたはリモートのcommitと同じcommitを指すmasterと呼ばれるローカルのbranchを得ることを見ましたね。
しかし、あなたはまだ見ていないのは、あなたがまたリモート上のそのbranchの最後の既知の位置のローカルコピーを得ることです。
あなたは複数のリモートを設定出来るので、リモート上のbranchの名前と同様に、そのbranchの名前はリモートの名前,originも含んでいます。
この場合は、スラッシュで2つに区切られたmaster。
それで、この場合、それはorigin/masterです。
そして、私達は丁度リモートと交信したので、それは現在、実際のリモートのバージョンと同じ場所です。
あなたがローカルのmaster branchにcommitした時に何が起きるか考えてみましょう。
通常、あなたがbranchにcommitする時は、そのbranchはその新規commitを指すように更新されます。
しかし、ローカルのorigin/master branchもGithubリポジトリ上の実際のmaster branchも更新されません。
何故ならば、あなたが更新したいと交信しなかったので。
しかしながら、もしあなたがmaster branchをpushしたら、ローカルのorigin/master branchとリモートのGitHub branchは新規commitと一緒に更新されるでしょう。
同様に、もしこのbranchがGitHubで更新されて、次に私達がpullしたら、これらは両方とも新規commitと一緒に更新されるでしょう。
戻ってもしあなたが異なった変更をローカルで1個、もう一個をリモートの各リポジトリでしたら何が起きるのかについて考えてみましょう。
あなたはgit fetchコマンドを実行してあなたの実際のローカルバージョンはそのままにしておいて、リモートbranchのローカルコピーだけ更新出来ると分かっています。　
このような場合では、潜在的な変更の衝突があります。あなたは、git logとgit diffを使ってローカルとリモートリポジトリの両方で、どんな変更が導入されたのか見ることが出来るように、git fetchを使用して、リモートbranchのローカルコピーだけ更新するのはナイスですね。
この方法で、もしあなたが暫くオフラインになるとして、例えばあなたが飛行機に乗るところとしましょう、あなたは自分のリモートbranchのローカルコピーを飛行機に乗る前に更新出来ます。
そして、あなたがオフラインになっている間に、あなたが最後に同期してからリモートに加えられたどんな更新にもアクセス出来るでしょう。
しかし、あなたは即座にこれらのcommitを結合する必要はありません。
変更の結合といえば、あなたがGitHubから自分のローカルリポジトリにcommitしたからには、
今やgit mergeを使ってそれらをあなたのmaster branchに合併することが可能です。
これは正にあなたがgit pullをした時に起こることだと分かります。
最初にリモートのbranchがfetchされます。リモートのbranchのローカルコピーが更新されます。
次に、そのbranchがlocalのbranchにmergeされます。
もっと具体的にすると、この場合、fetchがGitHubのmaster branchの内容でorign/masterを更新します。
そして次に、origin/master branchがmaster branchにmargeされます。
なので、git pullはgit fetchに続いてgit mergeをするのと同じです。
さて、Carolineがレシピリポジトリでコマンドラインからこのプロセスを行うデモします。

私はローカルコピーをgit fetch originを実行して更新できます。それはoriginリモートの各branchの全てのローカルコピーを更新します。私はgit log origin/masterを実行してローカルコピーを調査できます。
あるいはgit diff origin/master masterを実行して。
でも、私がこれをする前に、私はあなたにあなたがこれらのコマンドを実行した時に、あなたが見るものを前もって言っておきたいです。
あなたは、また自分が正しいか見るためにコマンドを自分で実行できます。でも、それを試す前に、これについて考えることは役に立つ事ができます。
私はあなたにあなたがgit fetchを実行する前と実行した後のgit logとgit statusの出力を予言します。
もしあなたがgit fetchを実行する前にgit log origin/masterを実行したら、これらのcommitのうちどれが表示されると思いますか？Larryのチリレシピを追加するcommit?あなたの新しいスパイスを追加するcommit?sarahのクミンを削除するcommit?当て嵌まるものすべてにチェックしなさい。
同様に、あなたがgit fetchを実行したあとに表示されると思う全てのcommitにチェックしなさい。
あなたがmaster branchでgit statusを実行した時、Gitはあなたのローカルmasterがorigin/masterから到達可能なcommitを含んでいるかどうか、その逆もあなたに知らせます。
もしあなたがgit fetchを実行する前にgit statusを実行したら、あなたのローカルのmasterはorigin/masterの1commit先に進んでいると表示しますか？origin/masterより1commit遅れていますか？あなたのbranchは最新と表示しますか？つまり2本のbranchが同じcommitを指していますか？或いは2本のbranchが同期していないよ表示しますか？
つまり、各branchには他のbranchには存在しないcommitがありますか？
同様に、あなたがgit fetchを実行したあとに、git statusは何と表示しますか？

Try Again
あなたが選択したgit fetch実行前のgit log origin/masterの出力は、git log masterを実行した時のものです。
origin/masterはあなたのローカルのmasterにはあるけれどもGitHubのmasterにはないcommitは表示しないということを思い出してください。

Try Again
git fetch実行後のあなたのgit log origin/masterの出力は完全に間違っています。
git fetchを実行したら、origin/masterはGitHubのmaster branchに現在存在するcommitは何でも含んでいる
ことを思い出してください。

Try Again
あなたのリポジトリとGitHubのリポジトリは同期していないので、git statusがこれを知らせてくれると思うかもしれません。でも思い出してください。git statusはmasterをローカルコピーのGitHubのリポジトリではなくorigin/masterと比較します。Sarahのcommitはまだorigin/masterにないので、git statusにどんな出力を期待しますか？

この質問に答えるために、git fetchの前と後で、どんなcommitがGitHubとあなたのローカルリポジトリに存在するのかについて考えてみましょう。
あなたがリポジトリをクローンした時、最新のcommitはLarryのチリのレシピを追加するcommitでしたので、それはまたあなたのローカルリポジトリの最新のcommitになりました。
もちろん、他の前のcommitはありましたが、スペースのために、ここではそれらは放置します。
さて、あなたは新しいスパイスを追加するcommitをしたので、そのcommitもまたあなたのローカルリポジトリにあります。
そして、それがあなたのmaster branchがあるところです。
origin/masterは、あなたがクローンした時に、まだリモートにあったcommitを指している。
あなたがクローンしたあとで、Sarahはcumin無しのcommitをGitHubで追加したが、
あなたのorigin/master branchはそれをまだ反映しません。それで、これはGitHubのmasterの状態です。
さて、これがあなたあがgit fetch実行前の両方のリポジトリの状態でした。
なので、もしあなたがgit log origin/masterを実行したら、あなたはそのLarryのチリのレシピを追加するcommitはありましたが、あなたは新規レシピを追加してSarahのクミンを取り除くcommitはorigin/masterには存在しませんでした。
もしあなたがgit statusを実行したら、あなたのbranchがorigin/masterよりもcommit1個分進んでいる(Ahead)のを見たでしょう。
これは理に適っています。何故ならばgit logとgit statusは両方ともインターネットにアクセスしないで実行されるので。
あなたがインターネットにアクセスできないどこかにいたとして、これらのコマンドを実行するとします。
あなたのローカルgitリポジトリはクミンのcommitが存在したか全く分からないでしょう。
なので、もちろん、あなたがgit log origin/masterを実行しても、(Sarahがgitリポジトリでレシピからクミンを削除したcommit)クミンのcommitは表示されないでしょう。
そして、git statusはあなたのbranchが実際に同期していないということは知らないでしょう。
それは、あなたのbranchは単に進んでいると思います。
さて、あなたがgit fetchを実行すると、gitはクミン削除のcommitをfetchしてきて、origin/master branchを更新してその新しいcommitを指すようにします。
あなたのローカルのmasterは未だに前にやっていたように新しいスパイスを追加するcommitを指しています。
それで、この時点で、あなたはクミン削除のローカルコピーのcommitをセーブしました。
そして、そのcommit(ローカルのorigin/master branchのクミン削除のcommit)にgit logからアクセス出来ます。
もしあなたがgit logを今実行すると、あなたはクミン削除のcommitとチリのcommitが見えます。
あなたは、未だに自分の新しいスパイスを追加するcommitが見せません。それは、唯一あなたのローカルmaster branchにあるだけなので。
さて、origin/masterとmasterの両方とも片方のbranchには存在しないcommitを1個もっています。
git statusはあなたのbranchがorigin/masterと同期していないと表示するでしょう。

私は既にgit fetchを実行したので、私のorigin/masterはSarahの変更を含んでいるでしょう。それは私がgit statusを実行すれば確認出来ます。
期待したとおり、私は自分のbranchとorigin/masterが分岐して、それぞれ1個ずつ異なったcommitを持っています。
さて、私はSarahの変更を自分のローカルのmasterにmergeする準備ができました。
それをするために、最初に私は自分がmaster branchにcheck outしてるか確認します。
次に私はgit mergeを実行します。そして私がmergeしたい2本のbranchはmasterとorigin/masterです。
私が期待していたように、私はmergeの衝突を得ました。なので、私はそれを解決するために、そのファイルを開きます。
そして、ここに我々二人が変更するまえのオリジナルのバージョンがあるのが見えます。
ここにオニオンパウダーを追加した私の変更があって、ここにSarahのクミンを削除したバージョンがあります。
私はSarahのバージョンを取って、それにオニオンパウダーを追加します。
そして、他のバージョンの両方共削除して、私の変更をセーブします。最後に、私はチリレシピをaddしてcommitしてgitに衝突が解決されたことを知らせます。
いつものように、私がmergeするとき、gitは私に自動でcommitメッセージを作成します。今回は私に
remote-tracking branch 'origin/master'と知らせてくれます。
git　pullを実行することは、git fetchをして次にgit mergeを実行するのと同じなので、
私はgit pull origin/masterと実行しても同じことが起きるでしょう。
もし、私がこれを今実行すると、masterは既に最新ですと見えます。
これは理に適っています。さて、git pullかgit fetchとgit mergeの両方を実行して自分で、あなたの変更とSarahの変更のmergeバージョンを作成してください。
そしてmergeバージョンをGitHubにpushしてください。
完了したら、git statusを実行して出力をこのボックスにペーストしなさい。

私の変更をリモートにpushするには、git push origin masterを実行します。
そしてgit statusを実行すると、私は今現在、origin/masterと最新であると見えます。
私は進んでも遅れてもいません。なぜなら、今私はSarahの変更を自分のローカルのmasterにmergeして、自分の変更を
GitHubのmasterにpushでアップしたからです。

この時点で、あなたは幾つか疑問を持っているかもしれません。
もしGit pullがgit fetchのあとにgit mergeするのと同じなのか不思議に思うかもしれません。
なぜ、私達の前回のpullはこのcommitが行ったようなmerge commitを発生しなかったのか？
それは当然な疑問です。
その答えはfast-forward merge(早送りのmerge)です。
この種のmergeはあなたが2つのcommitをmergeするときに起こります。
mergeのうちの一個がもう一個の祖先であるときです。
要するに、一個のcommitがもう一個のcommitから到達可能なときです。
もし、全てのmergeが今まで私達があなたに示したようなやり方で起きれば、もしあなたがbを指定してそれをaにmergeすれば、次に両方のcommitを親とするmerge commitで終わって、あなたはaに移動するでしょう。
通常の場合、merge commitはこの新ステージに到着するのに役割を果たす全てのcommitを追跡するために発生します。
しかし、この場合では、その役割を果たすcommitが、これ(b)と、これ(bの1個前)です。
そして、このcommit(b)は既にこのcommit(bの1個前)の履歴について全情報を持っています。なので、この余分なcommit(a)を追加する実際の理由はありません。
なので、新しいcommitを追加する代わりに、私達は、代わりにここ(b)を指すようにラベルを更新しさえすれば良いのです。
幸いなことに、この時点で、fast-forward(早送り)mergeという名前は理に適っています。
私達はその家系のどこかのbranchの履歴からラベルを取っています。　そして、そのラベルをbranchの先端に移動させます。
これらのcommit履歴を見て下さい。
branch bをbranch aにmergeした結果、fast-forward mergeになる各ダイアグラムの隣のボックスにチェックしなさい。

Great!
正解の両方のダイアグラムは、bからaに到達可能なので、fast-forward mergeが出来ます。

何かがfast-forward mergeかどうかの唯一の基準は、もし、あなたがmerge先にしようとしているbranchが、
あなたがmerge元にしようとしているbranchの祖先であるかということを思い出してください。
これはその例です。とても明快です。
もし、bから遡るとaにつきます。なので、このダイアグラムは明らかにfast-forward mergeです。
この場合もまた、bからaにつきます。これも、もう一つの行くべき道でしょう。これは完全の履歴内なので、私達はこれにチェックします。
これは、bからaにたどり着く道がありません。bから最初のcommitへの線状のどこにもaを見つける場所がないので。なので、ここはNo。私達はfast-forward merge出来ません。
私達は新規commitを作成しなければなりません。
同様に、この場合も、bから最初のcommitへの道筋にaがありません。なので、ここもチェックできません。

Reflect:リモートbranchのローカルコピー
今、あなたはリモートbranchのローカルコピーの更新の仕方を見ました。そして複数の人からの衝突する変更を結合するやり方も見ました。以下の質問とあなたの考えをreflectionファイルに追加しなさい。
あなたは、また変更をcommitしてpushしたいかもしれません。終わったらNextをクリックしてCarolineがPull Requestと呼ばれる共同作業しやすくするGitHubの機能を紹介します。

リモートに保存された最新の状態のコピーをローカルに持つことの利点は何ですか？
他の人がGitHubで変更を加えたバージョンとは別に、自分のローカルのbranchで自分の更新ができるし、
自分のローカルのbranch=masterとローカルにコピーしたGitHub上のbranch=origin/masterをlogで更新履歴を見たり、diffで比較したり出来る。自分のmasterとGitHubのローカルコピーであるorigin/masterをmergeして、それを
さらにpushでGitHubに上げれば、自分の変更をGitHubで他の人と共有出来る。

さて、あなたはGitHubでそれらを共有して、変更をパブリックにするやり方を見ました。
私はmaster branchを更新する前に、あなたがプロジェクトへの自分の変更に対するフィードバックを得るワークフローをあなたに見せたいです。　
例として、ここに私のコンピューターのローカル上とGitHubの私のforkの両方にレシピのリポジトリがあります。
もし、私が変更したら、私はそれに対するフィードバックが欲しいです。
次に、まず最初に私はその変更をローカルでもう一本の分けたbranchで行います。
次に私はその変更を自分のforkにpushします。すると、私の変更はGitHubで共有されるので、Sarahはそれを見ることが出来ます。それはmaster branchではありません。その課程でSarahもしSarahが私の変更に問題を見つけたら、彼女がそれを評価するとき、私は壊れたmaster branchは持ちません。
次に、私はPullリクエストというGitHubの機能を使って、Sarahが私が変更したものを正確に見て、コメントを残しやすくします。
両方共準備が出来たら、私はこの変更をmaster branchにmergeします。
今すぐ、私はケーキのレシピをサラダ油の代わりにキャノーラオイルを使うように変更したいです。より健康的なので。
まず最初に、私はdifferent-oilと呼ぶ新規branchを作成します。
次にそのbranchにcheckoutして変更に進みます。
さて、私はSarahに私が行った変更を見せたいので、私はそれをaddしてcommitしてpushします。
今度は私がmaster branchの代わりにdifferent-oil branchをpushするためにgit push origin different-oilを実行したことに留意してください。
さて、私は自分のbranchをpushして、GitHubでそのbranchを確認出来ます。
どんなbranchが存在するのか見るために、このドロップダウンメニューを選んで、私が今master branchを見ていることが分かるので、こっちが私がpushしたdifferent-oil branchです。
このbranchのリストはもし私がGitHubのリポジトリでgit branchを実行したら見るであろうリストと同じリストです。
私がGitHubにpushした唯一のbranchが表示されました。
different-oil branchでファイルがどんなふうに見えるか見るために、私はそれをクリックします、それはgit checkoutを実行するのと似ていますね。
Sarahもまたこれを行うことが出来ます。そして私がどんな変更を行ったか見るためにcommit履歴を眺めます。
代わりに、私が自分の変更のpullリクエストを作成するつもりですが。
私は、リポジトリのメインページに戻って、私は最近そのbranchをpushしたので、ここのcompare & pull requestボタンクリック出来ます。
でも、もし私がそのbranchをpushしたのがもっと前だったら、そのボタンはありませんので、私はこのbranchにcheckoutしてスクロールで少し下がって、Pull Requestをクリックします。
デフォルトでは、GitHubは私が自分の変更をオリジナルのリポジトリであるLarryのリポジトリにmergeしたいのだと想定します。
しかし代わりに、私は自分の変更を自分のforkのmaster branchにmergeしたいです。
なので、私は右にスクロールしてEditをクリックします。そして、私はbase forkをcbuckey-uda/recipesに変更出来ます。
さて、私はスクロールで下がって右に行って、Create pull requestをクリックします。
さて、GitHubはこのpull requestに現存する全commitと、行われた全変更を表示するビューを作成します。
もし、私がリポジトリに戻って、右にスクロールすると、私はまてPullリクエストのリストを見ることができます。
Sarahはこのリストをチェックして私がこれらの変更をmasterにmergeしたいということを見ることができます。
さて、Sarahが私のpullリクエストを見る間、私はあなたをSarahのほうに向けます。

私はCarolineのレシピのリポジトリのforkを見ているので、彼女がpullリクエストをしたときに私は通知のemailを受信しました。
私はGitHubのpullリクエストを見るためにこのemailを通じてクリック出来ます。
あなたは何故、これらがpullリクエストと呼ばれるのか不思議に思うかもしれません。
Carolineがこのリクエストを開始しましたが、彼女は何かをpullするように頼んでいません。
彼女は彼女の変更のうちの一つをmasterにmergeしようとしています。或いは、あなたは、彼女がmasterにpushしようとしていると、これを考えるかもしれません。
それでは、なぜそれがpull requestと呼ばれるのでしょう？
それは、何故ならば、彼女は私が彼女のbranchをmaster branchにpullするようにリクエストしているからです。
これの、別の良い名前はmergeリクエストかもしれません。しかし、pullリクエストがGitHubが採用しているものなので、
私達もそれで行きましょう。
それで、Carolineは私に彼女のdifferent-oil branchをmaster branchにmergeさせたがっています。
master branchが主要branchなので、人々がそのリポジトリに最初にやってきた時に眼にするbranchです。
私は実際にmergeする前に、それが本当に良く見えるか確認したい。
それでは。彼女は丁度サラダ油を、oh、キャノールに変更したようですね？
私はpullリクエストの名前に基づくと彼女はキャノーラを意味したんだと思います。
私は本当はこれをmergeしたくありません。何故なら、スペルエラーがあるからです。
もし誰かが後でこれを見たら、それは多分混乱します。
なので、それを今mergeする代わりに、私は実際にコメントを残すつもりです。
私は変更全体にコメントするのに、ここにコメントを入力できます。又はインライン化したコメントもここにできます。
私はそのオプションを選択しようと思います。この時点で、私は、メインのpullリクエストに戻ります。
もしもっとcommitがあったら、私はここでそれらを見れますが、一つだけなので、私は他に何も見る必要がありません。
もし、私がその変更で良く、今すぐpullする準備が出来ていると決めたら、私はこのMerge pull requestボタンを押します。
このボタンはmergeが衝突なしで通る時にだけ表示されます。
なので、その人が本当にmergeする準備が出来ているのかいないかどうか、変更を評価するのに良い標識です。
もし、そのmergeがmergeの衝突を作成していたら、私はCarolineにmasterを彼女のbranchにまず最初にmergeするように頼みます。私が彼女がその衝突を解決するやり方を見られるように。
そんなふうに、私は彼女のコードが最終的にmasterに追加されたと分かると、悪いmergeで何かが間違えるという機会はなくなります。
いいですね、この時点であなたは進んで、Carolineがmasterの新規branchを作成して説明した変更をすべきです。
そしてキャノーラを指示してサラダ油を切り替える変更をcommitすべきです。
あなたがあとでpullリクエストを更新する理由を持てるように、あなたは誤字やその他の間違いを故意に出来ます。
あなたはする必要がありません。
進んであなたの新規branchをforkにpushして、GitHubを使用して、pullリクエストを開始してください。
でもまだ、Mergeボタンをクリックしないように確認して下さい。

では、最初から始めましょう。このアクションでは、私達はREADMEを編集してセーブします。これはワーキングディレクトリだけに影響を与えます。さて、これについてはどうでしょう、git add README?
これはワーキングディレクトリから変更を取って、それをステージングエリアに追加します。
ですから、ステージングエリアが変更されます。次はgit commitです。git commitを実行すると、
ステージングエリアからの変更でcommitを作成してmaster branchを更新します。
OK,それではgit pull origin masterは？これはGitHub上のmaster branchの現在のcommitを取って、
それをローカルのbranchにpullして、それを現在masterであるbranchにmergeします。
なので、ローカルのmasterが唯一変更されるものです。
次はgit push origin masterです。これはローカルのバージョンに現在あるbranchを取って、それをリモートにpushします。
なので、この操作はリモートを変更します。
OK、下が最後です。
もし、私達がalt branchをmaster branchにマージするためにpullリクエストをして、そのpullリクエストが了承されmerge inされたら、そのalt branchはmaterにmergeされます。
なので、GitHubのmaster branchだけが唯一更新されるものです。

私はSarahが私のpullリクエストにコメントしたと知らせるemailを受信しました。
彼女は私がcanolaをミススペルしたと言っています。では見に行ってみましょう。
Canols oil.そうですね、それは間違っています。私は進んでそれを修正します。
そして私は自分の修正をcommitします。
さて、私はこの変更をGitHubでもまた見られるようにしたいので、私はpushします。
branchをpushすると自動的にGitHub上でpullリクエストが更新されます。
Sarahの私がミススペルしたことについてのコメントの下に、あなたは私が誤字を修正するcommitをしたということが見れます。
また、もし私がそのcommitを見ると、今2つのcommitがあることが分かります。
そして、もし私が変更されたファイルを見ると、正しいスペルが見えます。
さて、私はあなたにも同じステップとpullリクエストを自分でして欲しいです。
まず最初にdifferent-oilという新規branchを作成して、different-oil branchに私がしたようにサラダ油の代わりにキャノーラオイルを使うための違うcommitをします。
もし、したければ、わざと誤字を書くことも出来ますが、それはオプションです。
次に、different-oil branchを自分のGitHub上のforkにpushして、pullリクエストを作成してください。
Larryのリポジトリではなく、あなたのmaster branchへbaseを変更することを確認してください。
もし、さっき誤字を書いたら、もう一個、誤字を修正するcommitをして、pullリクエストを更新してください。
最後にあなたのpullリクエストへのリンクをこのボックスに貼って下さい。
あなたのGitHubリポジトリを眺めると、自分のpullリクエストへのリンクを見つけることが出来ます。
右にスクロールして、Pullリクエストのリストを見ます。
そして、あなたのpullリクエストをクリックして、URLバーからこのURLをコピーしてください。
最後にあなたがpullリクエストをまだmergeしないことを確認してください。
もしmergeしてしまうと、このあとの演習が動作しません。

私のpullリクエストへのリンクはgithub.com/cbuckey-uda/recipes/pull/1です。
これは、このリポジトリで最初のpullリクエストだからです。
もしあなたのpullリクエストを作成するのに困ったら、フォーラムにあなたの問題を投稿してください。

Reflect:GitとGitHubを使ったコラボレーション
さて、あなたは複数の人々がGitHubを使ってプロジェクトへの変更を共有して、pullリクエストを使って提案された変更を評価できる方法を見ました。
以下の質問に進んで、あなたの考えを自分のreflectionファイルに追加しましょう。

GitやGitHub無しでどうやってコラボレーションしますか？何がより簡単で、何がより難しくなりますか？

GitHub無しの場合はコードをzipファイルにしてメールやDropboxでダウンロード出来るようにする。
メールで細かいことは伝える。コードをダウンロードしたら解答して編集する。

gitとGitHubの勉強をしないで使える。複数の人だと効率が非常に悪い。

あなたは、commitして変更をpushしたいかもしれません。
完了したらNextをクリック。






